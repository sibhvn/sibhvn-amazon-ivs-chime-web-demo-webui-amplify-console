{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst SignalingClientEventType_1 = require(\"../signalingclient/SignalingClientEventType\");\n\nconst SignalingProtocol_js_1 = require(\"../signalingprotocol/SignalingProtocol.js\");\n\nconst BaseTask_1 = require(\"./BaseTask\");\n/**\n * [[LeaveAndReceiveLeaveAckTask]] sends a Leave frame and waits for a LeaveAck.\n */\n\n\nclass LeaveAndReceiveLeaveAckTask extends BaseTask_1.default {\n  constructor(context) {\n    super(context.logger);\n    this.context = context;\n    this.taskName = 'LeaveAndReceiveLeaveAckTask';\n    this.taskCanceler = null;\n  }\n\n  cancel() {\n    if (this.taskCanceler) {\n      this.taskCanceler.cancel();\n      this.taskCanceler = null;\n    }\n  }\n\n  run() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.context.signalingClient.ready()) {\n        this.context.signalingClient.leave();\n        this.context.logger.info('sent leave');\n        yield this.receiveLeaveAck();\n      }\n    });\n  }\n\n  receiveLeaveAck() {\n    return new Promise((resolve, reject) => {\n      class Interceptor {\n        constructor(signalingClient, logger) {\n          this.signalingClient = signalingClient;\n          this.logger = logger;\n        }\n\n        cancel() {\n          this.signalingClient.removeObserver(this);\n          reject(new Error(`LeaveAndReceiveLeaveAckTask got canceled while waiting for IndexFrame`));\n        }\n\n        handleSignalingClientEvent(event) {\n          if (event.isConnectionTerminated()) {\n            this.signalingClient.removeObserver(this);\n            this.logger.info('LeaveAndReceiveLeaveAckTask connection terminated'); // don't treat this as an error\n\n            resolve();\n            return;\n          }\n\n          if (event.type === SignalingClientEventType_1.default.ReceivedSignalFrame && event.message.type === SignalingProtocol_js_1.SdkSignalFrame.Type.LEAVE_ACK) {\n            this.signalingClient.removeObserver(this);\n            this.logger.info('got leave ack');\n            resolve();\n          }\n        }\n\n      }\n\n      const interceptor = new Interceptor(this.context.signalingClient, this.context.logger);\n      this.taskCanceler = interceptor;\n      this.context.signalingClient.registerObserver(interceptor);\n    });\n  }\n\n}\n\nexports.default = LeaveAndReceiveLeaveAckTask;","map":{"version":3,"mappings":"cAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;;AAEA;;AAEA;AAEA;;;;;AAGA,MAAqBA,2BAArB,SAAyDC,kBAAzD,CAAiE;EAI/DC,YAAoBC,OAApB,EAAsD;IACpD,MAAMA,OAAO,CAACC,MAAd;IADkB;IAHV,gBAAW,6BAAX;IACF,oBAAoC,IAApC;EAIP;;EAEDC,MAAM;IACJ,IAAI,KAAKC,YAAT,EAAuB;MACrB,KAAKA,YAAL,CAAkBD,MAAlB;MACA,KAAKC,YAAL,GAAoB,IAApB;IACD;EACF;;EAEKC,GAAG;;MACP,IAAI,KAAKJ,OAAL,CAAaK,eAAb,CAA6BC,KAA7B,EAAJ,EAA0C;QACxC,KAAKN,OAAL,CAAaK,eAAb,CAA6BE,KAA7B;QACA,KAAKP,OAAL,CAAaC,MAAb,CAAoBO,IAApB,CAAyB,YAAzB;QACA,MAAM,KAAKC,eAAL,EAAN;MACD;IACF;EAAA;;EAEOA,eAAe;IACrB,OAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAoB;MACrC,MAAMC,WAAN,CAAiB;QACfd,YAAoBM,eAApB,EAA8DJ,MAA9D,EAA4E;UAAxD;UAA0C;QAAkB;;QAEhFC,MAAM;UACJ,KAAKG,eAAL,CAAqBS,cAArB,CAAoC,IAApC;UACAF,MAAM,CACJ,IAAIG,KAAJ,CAAU,uEAAV,CADI,CAAN;QAGD;;QAEDC,0BAA0B,CAACC,KAAD,EAA4B;UACpD,IAAIA,KAAK,CAACC,sBAAN,EAAJ,EAAoC;YAClC,KAAKb,eAAL,CAAqBS,cAArB,CAAoC,IAApC;YACA,KAAKb,MAAL,CAAYO,IAAZ,CAAiB,mDAAjB,EAFkC,CAGlC;;YACAG,OAAO;YACP;UACD;;UAED,IACEM,KAAK,CAACE,IAAN,KAAeC,mCAAyBC,mBAAxC,IACAJ,KAAK,CAACK,OAAN,CAAcH,IAAd,KAAuBI,sCAAeC,IAAf,CAAoBC,SAF7C,EAGE;YACA,KAAKpB,eAAL,CAAqBS,cAArB,CAAoC,IAApC;YACA,KAAKb,MAAL,CAAYO,IAAZ,CAAiB,eAAjB;YACAG,OAAO;UACR;QACF;;MA3Bc;;MA8BjB,MAAMe,WAAW,GAAG,IAAIb,WAAJ,CAAgB,KAAKb,OAAL,CAAaK,eAA7B,EAA8C,KAAKL,OAAL,CAAaC,MAA3D,CAApB;MACA,KAAKE,YAAL,GAAoBuB,WAApB;MACA,KAAK1B,OAAL,CAAaK,eAAb,CAA6BsB,gBAA7B,CAA8CD,WAA9C;IACD,CAlCM,CAAP;EAmCD;;AA3D8D;;AAAjEE","names":["LeaveAndReceiveLeaveAckTask","BaseTask_1","constructor","context","logger","cancel","taskCanceler","run","signalingClient","ready","leave","info","receiveLeaveAck","Promise","resolve","reject","Interceptor","removeObserver","Error","handleSignalingClientEvent","event","isConnectionTerminated","type","SignalingClientEventType_1","ReceivedSignalFrame","message","SignalingProtocol_js_1","Type","LEAVE_ACK","interceptor","registerObserver","exports"],"sourceRoot":"","sources":["../../src/task/LeaveAndReceiveLeaveAckTask.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}