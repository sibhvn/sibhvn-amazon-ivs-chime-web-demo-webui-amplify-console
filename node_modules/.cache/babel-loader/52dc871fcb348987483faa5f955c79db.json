{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst DefaultBrowserBehavior_1 = require(\"../browserbehavior/DefaultBrowserBehavior\");\n\nconst DefaultSDP_1 = require(\"../sdp/DefaultSDP\");\n\nconst BaseTask_1 = require(\"./BaseTask\");\n/*\n * [[SetRemoteDescriptionTask]] asynchronously calls [[setRemoteDescription]] on the\n * peer connection and then waits for the tracks to be added and for the ICE connection\n * to complete.\n */\n\n\nclass SetRemoteDescriptionTask extends BaseTask_1.default {\n  constructor(context) {\n    super(context.logger);\n    this.context = context;\n    this.taskName = 'SetRemoteDescriptionTask';\n  }\n\n  cancel() {\n    if (this.cancelICEPromise) {\n      this.cancelICEPromise();\n    }\n  }\n\n  run() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const peer = this.context.peer;\n\n      if (!peer) {\n        this.logAndThrow('session does not have peer connection; bypass set remote description');\n      }\n\n      let sdp = this.context.sdpAnswer;\n      sdp = new DefaultSDP_1.default(sdp).withoutServerReflexiveCandidates().sdp;\n\n      if (this.context.audioProfile) {\n        sdp = new DefaultSDP_1.default(sdp).withAudioMaxAverageBitrate(this.context.audioProfile.audioBitrateBps).sdp;\n\n        if (this.context.audioProfile.isStereo()) {\n          sdp = new DefaultSDP_1.default(sdp).withStereoAudio().sdp;\n        }\n      }\n\n      if (!this.context.browserBehavior.requiresUnifiedPlan()) {\n        // Under Plan B if our offer has video, but we're not going to subscribe to\n        // any videos, ensure that the answer has video (marked inactive). If\n        // it doesn't, WebRTC will reject the SDP answer. This happens on Chrome\n        // when going from receiving one video to zero videos. The server does not\n        // provide a video m-line when there are no videos available under Plan B,\n        // thus we need to synthesize a video m-line by copying the one from the offer.\n        this.logger.info('checking for no videos (plan-b)');\n\n        if (this.context.videosToReceive.empty() && this.context.peer.remoteDescription) {\n          this.logger.info('have no videos and have remote description (plan-b)');\n          const sdpInactiveVideoOffer = this.context.peer.localDescription.sdp;\n          const sdpInactiveVideoAnswer = sdp;\n          let updatedAnswer = sdpInactiveVideoAnswer;\n          const offer = new DefaultSDP_1.default(sdpInactiveVideoOffer);\n\n          if (offer.hasVideo()) {\n            this.logger.info(`offer has video (plan-b): >>>${offer.sdp}<<<`);\n            const answer = new DefaultSDP_1.default(sdpInactiveVideoAnswer);\n            this.logger.info(`existing answer (plan-b): >>>${answer.sdp}<<<`);\n\n            if (!answer.hasVideo()) {\n              this.logger.info(`copying inactive video from offer into answer (plan-b); sdp answer before is >>>${sdpInactiveVideoAnswer}<<<`);\n              updatedAnswer = answer.copyVideo(sdpInactiveVideoOffer).sdp;\n            }\n          }\n\n          sdp = updatedAnswer;\n        }\n      }\n\n      if (new DefaultBrowserBehavior_1.default().requiresSortCodecPreferencesForSdpAnswer()) {\n        sdp = new DefaultSDP_1.default(sdp).preferH264IfExists().sdp;\n      }\n\n      this.logger.info(`processed remote description is >>>${sdp}<<<`);\n      const remoteDescription = {\n        type: 'answer',\n        sdp: sdp,\n        toJSON: null\n      };\n\n      try {\n        yield this.createICEConnectionCompletedPromise(remoteDescription);\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n\n  createICEConnectionCompletedPromise(remoteDescription) {\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      const checkConnectionCompleted = () => {\n        if (this.context.peer.iceConnectionState === 'connected' || this.context.peer.iceConnectionState === 'completed') {\n          this.context.peer.removeEventListener('iceconnectionstatechange', checkConnectionCompleted);\n          resolve();\n        }\n      };\n\n      this.cancelICEPromise = () => {\n        if (this.context.peer) {\n          this.context.peer.removeEventListener('iceconnectionstatechange', checkConnectionCompleted);\n        }\n\n        reject(new Error(`${this.name()} got canceled while waiting for the ICE connection state`));\n      };\n\n      this.context.peer.addEventListener('iceconnectionstatechange', checkConnectionCompleted);\n\n      try {\n        yield this.context.peer.setRemoteDescription(remoteDescription);\n        this.logger.info('set remote description, waiting for ICE connection');\n        checkConnectionCompleted();\n      } catch (err) {\n        reject(err);\n      }\n    }));\n  }\n\n}\n\nexports.default = SetRemoteDescriptionTask;","map":{"version":3,"mappings":"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","names":["SetRemoteDescriptionTask","BaseTask_1","constructor","context","logger","cancel","cancelICEPromise","run","peer","logAndThrow","sdp","sdpAnswer","DefaultSDP_1","withoutServerReflexiveCandidates","audioProfile","withAudioMaxAverageBitrate","audioBitrateBps","isStereo","withStereoAudio","browserBehavior","requiresUnifiedPlan","info","videosToReceive","empty","remoteDescription","sdpInactiveVideoOffer","localDescription","sdpInactiveVideoAnswer","updatedAnswer","offer","hasVideo","answer","copyVideo","DefaultBrowserBehavior_1","requiresSortCodecPreferencesForSdpAnswer","preferH264IfExists","type","toJSON","createICEConnectionCompletedPromise","err","Promise","resolve","reject","__awaiter","checkConnectionCompleted","iceConnectionState","removeEventListener","Error","name","addEventListener","setRemoteDescription","exports"],"sourceRoot":"","sources":["../../src/task/SetRemoteDescriptionTask.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}