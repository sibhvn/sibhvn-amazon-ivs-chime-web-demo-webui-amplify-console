{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst MeetingSessionVideoAvailability_1 = require(\"../meetingsession/MeetingSessionVideoAvailability\");\n\nconst DefaultModality_1 = require(\"../modality/DefaultModality\");\n\nconst SignalingClientEventType_1 = require(\"../signalingclient/SignalingClientEventType\");\n\nconst SignalingProtocol_js_1 = require(\"../signalingprotocol/SignalingProtocol.js\");\n\nconst Types_1 = require(\"../utils/Types\");\n\nconst BaseTask_1 = require(\"./BaseTask\");\n/*\n * [[ReceiveVideoStreamIndexTask]] receives [[SdkIndexFrame]] and updates [[VideoUplinkBandwidthPolicy]] and [[VideoDownlinkBandwidthPolicy]].\n */\n\n\nclass ReceiveVideoStreamIndexTask extends BaseTask_1.default {\n  constructor(context) {\n    super(context.logger);\n    this.context = context;\n    this.taskName = 'ReceiveVideoStreamIndexTask'; // See comment above invocation of `pauseIngestion` in `DefaultAudioVideoController`\n    // for explanation.\n\n    this.isIngestionPaused = false;\n    this.pendingIndex = null;\n  }\n\n  removeObserver() {\n    this.context.signalingClient.removeObserver(this);\n  }\n\n  run() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.handleIndexFrame(this.context.indexFrame);\n      this.context.signalingClient.registerObserver(this);\n      this.context.removableObservers.push(this);\n    });\n  }\n\n  handleSignalingClientEvent(event) {\n    if (event.type !== SignalingClientEventType_1.default.ReceivedSignalFrame || event.message.type !== SignalingProtocol_js_1.SdkSignalFrame.Type.INDEX) {\n      return;\n    } // @ts-ignore: force cast to SdkIndexFrame\n\n\n    const indexFrame = event.message.index;\n    this.context.logger.info(`received new index ${JSON.stringify(indexFrame)}`);\n    this.handleIndexFrame(indexFrame);\n  }\n\n  pauseIngestion() {\n    this.isIngestionPaused = true;\n  }\n\n  resumeIngestion() {\n    if (!this.isIngestionPaused) {\n      // Do not recheck subcribe if it wasn't paused to begin with.\n      return;\n    }\n\n    this.isIngestionPaused = false;\n\n    if (this.pendingIndex) {\n      this.context.logger.info('Resuming index ingestion with pending index');\n      this.handleIndexFrame(this.pendingIndex);\n    }\n  }\n\n  handleIndexFrame(indexFrame) {\n    if (!indexFrame) {\n      return;\n    }\n\n    if (this.isIngestionPaused) {\n      this.context.logger.info(`Index ingestion is paused, setting most recent index as pending`);\n      this.pendingIndex = indexFrame;\n      return;\n    } else {\n      this.pendingIndex = null;\n    } // Filter out self content share video\n\n\n    const selfAttendeeId = this.context.audioVideoController.configuration.credentials.attendeeId;\n    indexFrame.sources = indexFrame.sources.filter(source => {\n      const modality = new DefaultModality_1.default(source.attendeeId);\n      return !(modality.base() === selfAttendeeId && modality.hasModality(DefaultModality_1.default.MODALITY_CONTENT));\n    });\n    const {\n      videoStreamIndex,\n      videoDownlinkBandwidthPolicy,\n      videoUplinkBandwidthPolicy\n    } = this.context;\n    const oldVideoSources = videoStreamIndex.allVideoSendingSourcesExcludingSelf(selfAttendeeId);\n    videoStreamIndex.integrateIndexFrame(indexFrame);\n    videoDownlinkBandwidthPolicy.updateIndex(videoStreamIndex);\n    videoUplinkBandwidthPolicy.updateIndex(videoStreamIndex);\n    this.resubscribe(videoDownlinkBandwidthPolicy, videoUplinkBandwidthPolicy);\n    this.updateVideoAvailability(indexFrame);\n    this.handleIndexVideosPausedAtSource(); // `forEachObserver`is asynchronous anyways so it doesn't matter (for better or worse) whether we\n    // trigger it before or after the policy update + possible resubscribe kickoff\n\n    const newVideoSources = videoStreamIndex.allVideoSendingSourcesExcludingSelf(selfAttendeeId);\n\n    if (!this.areVideoSourcesEqual(oldVideoSources, newVideoSources)) {\n      this.context.audioVideoController.forEachObserver(observer => {\n        Types_1.Maybe.of(observer.remoteVideoSourcesDidChange).map(f => f.bind(observer)(newVideoSources));\n      });\n    }\n  }\n\n  areVideoSourcesEqual(oldVideoSources, newVideoSources) {\n    if (oldVideoSources.length !== newVideoSources.length) {\n      return false;\n    }\n\n    const compare = (videoSourceA, videoSourceB) => videoSourceA.attendee.attendeeId.localeCompare(videoSourceB.attendee.attendeeId);\n\n    const sortedOldVideoSources = [...oldVideoSources].sort(compare);\n    const sortedNewVideoSources = [...newVideoSources].sort(compare);\n\n    for (let i = 0; i < sortedOldVideoSources.length; i++) {\n      if (sortedOldVideoSources[i].attendee.attendeeId !== sortedNewVideoSources[i].attendee.attendeeId) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  resubscribe(videoDownlinkBandwidthPolicy, videoUplinkBandwidthPolicy) {\n    const resubscribeForDownlink = videoDownlinkBandwidthPolicy.wantsResubscribe();\n    const resubscribeForUplink = (this.context.videoDuplexMode === SignalingProtocol_js_1.SdkStreamServiceType.TX || this.context.videoDuplexMode === SignalingProtocol_js_1.SdkStreamServiceType.DUPLEX) && videoUplinkBandwidthPolicy.wantsResubscribe();\n    const shouldResubscribe = resubscribeForDownlink || resubscribeForUplink;\n    this.logger.info(`should resubscribe: ${shouldResubscribe} (downlink: ${resubscribeForDownlink} uplink: ${resubscribeForUplink})`);\n\n    if (!shouldResubscribe) {\n      return;\n    }\n\n    const videoSubscriptionIdSet = videoDownlinkBandwidthPolicy.chooseSubscriptions();\n    this.context.videosToReceive = videoSubscriptionIdSet.truncate(this.context.videoSubscriptionLimit);\n\n    if (videoSubscriptionIdSet.size() > this.context.videosToReceive.size()) {\n      this.logger.warn(`Video receive limit exceeded. Limiting the videos to ${this.context.videosToReceive.size()}. Please consider using AllHighestVideoBandwidthPolicy or VideoPriorityBasedPolicy along with chooseRemoteVideoSources api to select the video sources to be displayed.`);\n    }\n\n    this.context.videoCaptureAndEncodeParameter = videoUplinkBandwidthPolicy.chooseCaptureAndEncodeParameters();\n    this.logger.info(`trigger resubscribe for up=${resubscribeForUplink} down=${resubscribeForDownlink}; videosToReceive=[${this.context.videosToReceive.array()}] captureParams=${JSON.stringify(this.context.videoCaptureAndEncodeParameter)}`);\n    this.context.audioVideoController.update({\n      needsRenegotiation: false\n    });\n  }\n\n  updateVideoAvailability(indexFrame) {\n    if (!this.context.videosToReceive) {\n      this.logger.error('videosToReceive must be set in the meeting context.');\n      return;\n    }\n\n    const videoAvailability = new MeetingSessionVideoAvailability_1.default();\n    videoAvailability.remoteVideoAvailable = !this.context.videosToReceive.empty();\n    videoAvailability.canStartLocalVideo = !indexFrame.atCapacity;\n\n    if (!this.context.lastKnownVideoAvailability || !this.context.lastKnownVideoAvailability.equal(videoAvailability)) {\n      this.context.lastKnownVideoAvailability = videoAvailability.clone();\n      this.context.audioVideoController.forEachObserver(observer => {\n        Types_1.Maybe.of(observer.videoAvailabilityDidChange).map(f => f.bind(observer)(videoAvailability.clone()));\n      });\n    }\n  }\n\n  handleIndexVideosPausedAtSource() {\n    const streamsPausedAtSource = this.context.videoStreamIndex.streamsPausedAtSource();\n\n    for (const tile of this.context.videoTileController.getAllVideoTiles()) {\n      const tileState = tile.state();\n\n      if (streamsPausedAtSource.contain(tileState.streamId)) {\n        if (tile.markPoorConnection()) {\n          this.logger.info(`marks the tile ${tileState.tileId} as having a poor connection`);\n        }\n      } else {\n        if (tile.unmarkPoorConnection()) {\n          this.logger.info(`unmarks the tile ${tileState.tileId} as having a poor connection`);\n        }\n      }\n    }\n  }\n\n}\n\nexports.default = ReceiveVideoStreamIndexTask;","map":{"version":3,"mappings":"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","names":["ReceiveVideoStreamIndexTask","BaseTask_1","constructor","context","logger","removeObserver","signalingClient","run","handleIndexFrame","indexFrame","registerObserver","removableObservers","push","handleSignalingClientEvent","event","type","SignalingClientEventType_1","ReceivedSignalFrame","message","SignalingProtocol_js_1","Type","INDEX","index","info","JSON","stringify","pauseIngestion","isIngestionPaused","resumeIngestion","pendingIndex","selfAttendeeId","audioVideoController","configuration","credentials","attendeeId","sources","filter","source","modality","DefaultModality_1","base","hasModality","MODALITY_CONTENT","videoStreamIndex","videoDownlinkBandwidthPolicy","videoUplinkBandwidthPolicy","oldVideoSources","allVideoSendingSourcesExcludingSelf","integrateIndexFrame","updateIndex","resubscribe","updateVideoAvailability","handleIndexVideosPausedAtSource","newVideoSources","areVideoSourcesEqual","forEachObserver","observer","Types_1","of","remoteVideoSourcesDidChange","map","f","bind","length","compare","videoSourceA","videoSourceB","attendee","localeCompare","sortedOldVideoSources","sort","sortedNewVideoSources","i","resubscribeForDownlink","wantsResubscribe","resubscribeForUplink","videoDuplexMode","TX","DUPLEX","shouldResubscribe","videoSubscriptionIdSet","chooseSubscriptions","videosToReceive","truncate","videoSubscriptionLimit","size","warn","videoCaptureAndEncodeParameter","chooseCaptureAndEncodeParameters","array","update","needsRenegotiation","error","videoAvailability","MeetingSessionVideoAvailability_1","remoteVideoAvailable","empty","canStartLocalVideo","atCapacity","lastKnownVideoAvailability","equal","clone","videoAvailabilityDidChange","streamsPausedAtSource","tile","videoTileController","getAllVideoTiles","tileState","state","contain","streamId","markPoorConnection","tileId","unmarkPoorConnection","exports"],"sourceRoot":"","sources":["../../src/task/ReceiveVideoStreamIndexTask.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}