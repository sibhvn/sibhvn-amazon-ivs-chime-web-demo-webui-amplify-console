{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst DefaultBrowserBehavior_1 = require(\"../browserbehavior/DefaultBrowserBehavior\");\n\nconst DefaultVideoFrameProcessorPipeline_1 = require(\"./DefaultVideoFrameProcessorPipeline\");\n/**\n * [[DefaultVideoTransformDevice]] is an augmented [[VideoInputDevice]].\n * It transform the input {@link Device} with an array of {@link VideoFrameProcessor} to produce a `MediaStream`.\n */\n\n\nclass DefaultVideoTransformDevice {\n  constructor(logger, device, processors) {\n    let browserBehavior = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new DefaultBrowserBehavior_1.default();\n    this.logger = logger;\n    this.device = device;\n    this.processors = processors;\n    this.browserBehavior = browserBehavior;\n    this.observers = new Set();\n    this.pipe = new DefaultVideoFrameProcessorPipeline_1.default(this.logger, this.processors);\n    this.pipe.addObserver(this);\n  }\n  /**\n   * getter for `outputMediaStream`.\n   * `outputMediaStream` is returned by internal {@link VideoFrameProcessorPipeline}.\n   * It is possible, but unlikely, that this accessor will throw.\n   */\n\n\n  get outputMediaStream() {\n    return this.pipe.outputMediaStream;\n  }\n  /**\n   * `chooseNewInnerDevice` preserves the inner pipeline and processing state and switches\n   * the inner device. Since the pipeline and processors are shared with the new transform device\n   * only one transform device can be used.\n   */\n\n\n  chooseNewInnerDevice(newDevice) {\n    const newTransformDevice = new DefaultVideoTransformDevice(this.logger, newDevice, this.processors, this.browserBehavior);\n    newTransformDevice.pipe = this.pipe;\n    return newTransformDevice;\n  }\n  /**\n   * Return the inner device as provided during construction.\n   */\n\n\n  getInnerDevice() {\n    return this.device;\n  }\n\n  intrinsicDevice() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const trackConstraints = {}; // Empty string and null.\n\n      if (!this.device) {\n        return trackConstraints;\n      } // Device ID.\n\n\n      if (typeof this.device === 'string') {\n        if (this.browserBehavior.requiresNoExactMediaStreamConstraints()) {\n          trackConstraints.deviceId = this.device;\n        } else {\n          trackConstraints.deviceId = {\n            exact: this.device\n          };\n        }\n\n        return trackConstraints;\n      }\n\n      if (this.device.id) {\n        // Nothing we can do.\n        return this.device;\n      } // It's constraints.\n\n\n      return Object.assign(Object.assign({}, this.device), trackConstraints);\n    });\n  }\n  /**\n   * Create {@link VideoFrameProcessorPipeline} if there is not a existing one and start video processors.\n   * Returns output `MediaStream` produced by {@link VideoFrameProcessorPipeline}.\n   */\n\n\n  transformStream(mediaStream) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.pipe.setInputMediaStream(mediaStream);\n      this.inputMediaStream = mediaStream;\n      return this.pipe.getActiveOutputMediaStream();\n    });\n  }\n  /**\n   * onOutputStreamDisconnect is called when device controller wants to detach\n   * the transform device. The default behavior is to stop the output\n   * media stream and release the input the media stream. If the input media stream\n   * is the provided device, it will not be released.\n   */\n\n\n  onOutputStreamDisconnect() {\n    this.logger.info('DefaultVideoTransformDevice: detach stopping input media stream');\n    const deviceIsMediaStream = this.device && this.device.id; // Stop processing but keep the pipe and processors\n\n    this.pipe.stop(); // Turn off the camera, unless device is a MediaStream\n\n    if (!deviceIsMediaStream) {\n      if (this.inputMediaStream) {\n        for (const track of this.inputMediaStream.getVideoTracks()) {\n          track.stop();\n        }\n      }\n    }\n  }\n  /**\n   * Dispose of the inner workings of the transform device, including pipeline and processors.\n   * `stop` can only be called when the transform device is not used by device controller anymore.\n   * After `stop` is called, all transform devices which share the pipeline must be discarded.\n   */\n\n\n  stop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.inputMediaStream) {\n        for (const track of this.inputMediaStream.getVideoTracks()) {\n          track.stop();\n        }\n      }\n\n      this.pipe.destroy();\n      this.inputMediaStream = null;\n    });\n  }\n  /**\n   * Add an observer to receive notifications about lifecycle events.\n   * See {@link DefaultVideoTransformDeviceObserver} for details.\n   * If the observer has already been added, this method call has no effect.\n   */\n\n\n  addObserver(observer) {\n    this.observers.add(observer);\n  }\n  /**\n   * Remove an existing observer. If the observer has not been previously. this method call has no effect.\n   */\n\n\n  removeObserver(observer) {\n    this.observers.delete(observer);\n  }\n\n  processingDidStart() {\n    this.logger.info('video transform device processing started');\n    this.forEachObserver(observer => {\n      if (observer.processingDidStart) {\n        observer.processingDidStart();\n      }\n    });\n  }\n\n  processingLatencyTooHigh(latencyMs) {\n    this.forEachObserver(observer => {\n      if (observer.processingLatencyTooHigh) {\n        observer.processingLatencyTooHigh(latencyMs);\n      }\n    });\n  }\n\n  processingDidFailToStart() {\n    this.logger.info('video transform device processing failed to start');\n    this.forEachObserver(observer => {\n      if (observer.processingDidFailToStart) {\n        observer.processingDidFailToStart();\n      }\n    });\n  }\n\n  processingDidStop() {\n    this.logger.info('video transform device processing stopped');\n    this.forEachObserver(observer => {\n      if (observer.processingDidStop) {\n        observer.processingDidStop();\n      }\n    });\n  }\n\n  forEachObserver(observerFunc) {\n    for (const observer of this.observers) {\n      setTimeout(() => {\n        observerFunc(observer);\n      }, 0);\n    }\n  }\n\n}\n\nexports.default = DefaultVideoTransformDevice;","map":{"version":3,"mappings":"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","names":["DefaultVideoTransformDevice","constructor","logger","device","processors","browserBehavior","DefaultBrowserBehavior_1","Set","pipe","DefaultVideoFrameProcessorPipeline_1","addObserver","outputMediaStream","chooseNewInnerDevice","newDevice","newTransformDevice","getInnerDevice","intrinsicDevice","trackConstraints","requiresNoExactMediaStreamConstraints","deviceId","exact","id","transformStream","mediaStream","setInputMediaStream","inputMediaStream","getActiveOutputMediaStream","onOutputStreamDisconnect","info","deviceIsMediaStream","stop","track","getVideoTracks","destroy","observer","observers","add","removeObserver","delete","processingDidStart","forEachObserver","processingLatencyTooHigh","latencyMs","processingDidFailToStart","processingDidStop","observerFunc","setTimeout","exports"],"sourceRoot":"","sources":["../../src/videoframeprocessor/DefaultVideoTransformDevice.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}