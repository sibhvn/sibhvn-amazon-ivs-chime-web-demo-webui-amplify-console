{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst DefaultBrowserBehavior_1 = require(\"../browserbehavior/DefaultBrowserBehavior\");\n\nconst AsyncScheduler_1 = require(\"../scheduler/AsyncScheduler\");\n\nclass DefaultAudioMixController {\n  constructor(logger) {\n    this.logger = logger;\n    this.audioDevice = null;\n    this.audioElement = null;\n    this.audioStream = null;\n    this.browserBehavior = new DefaultBrowserBehavior_1.default();\n    this.observers = new Set();\n  }\n\n  bindAudioElement(element) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!element) {\n        throw new Error(`Cannot bind audio element: ${element}`);\n      }\n\n      this.audioElement = element;\n      this.audioElement.autoplay = true;\n      return this.bindAudioMix();\n    });\n  }\n\n  unbindAudioElement() {\n    if (!this.audioElement) {\n      return;\n    }\n\n    this.audioElement.srcObject = null;\n    this.audioElement = null;\n    this.forEachObserver(observer => {\n      if (this.audioStream) {\n        observer.meetingAudioStreamBecameInactive(this.audioStream);\n      }\n    });\n  }\n\n  bindAudioStream(stream) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!stream) {\n        return;\n      }\n\n      this.audioStream = stream;\n\n      try {\n        yield this.bindAudioMix();\n      } catch (error) {\n        /* istanbul ignore else */\n        if (this.logger) {\n          this.logger.warn(`Failed to bind audio stream: ${error}`);\n        }\n      }\n    });\n  }\n\n  bindAudioDevice(device) {\n    return __awaiter(this, void 0, void 0, function* () {\n      /**\n       * Throw error if browser doesn't even support setSinkId\n       * Read more: https://caniuse.com/?search=setSinkId\n       */\n      if (device && !this.browserBehavior.supportsSetSinkId()) {\n        throw new Error('Cannot select audio output device. This browser does not support setSinkId.');\n      } // Always set device -- we might be setting it back to `null` to reselect\n      // the default, and even in that case we need to call `bindAudioMix` in\n      // order to update the sink ID to the empty string.\n\n\n      this.audioDevice = device;\n      return this.bindAudioMix();\n    });\n  }\n\n  forEachObserver(observerFunc) {\n    for (const observer of this.observers) {\n      AsyncScheduler_1.default.nextTick(() => {\n        observerFunc(observer);\n      });\n    }\n  }\n\n  bindAudioMix() {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.audioElement) {\n        return;\n      }\n\n      const previousStream = this.audioElement.srcObject;\n\n      if (this.audioStream) {\n        this.audioElement.srcObject = this.audioStream;\n      }\n\n      if (previousStream !== this.audioStream) {\n        this.forEachObserver(observer => {\n          if (previousStream) {\n            observer.meetingAudioStreamBecameInactive(previousStream);\n          }\n\n          if (this.audioStream) {\n            observer.meetingAudioStreamBecameActive(this.audioStream);\n          }\n        });\n      } // In usual operation, the output device is undefined, and so is the element\n      // sink ID. In this case, don't throw an error -- we're being called as a side\n      // effect of just binding the audio element, not choosing an output device.\n\n\n      const shouldSetSinkId = ((_a = this.audioDevice) === null || _a === void 0 ? void 0 : _a.deviceId) !== this.audioElement.sinkId;\n\n      if (shouldSetSinkId && typeof this.audioElement.sinkId === 'undefined') {\n        throw new Error('Cannot select audio output device. This browser does not support setSinkId.');\n      }\n\n      const newSinkId = this.audioDevice ? this.audioDevice.deviceId : '';\n      const oldSinkId = this.audioElement.sinkId;\n\n      if (newSinkId === oldSinkId) {\n        return;\n      } // Take the existing stream and temporarily unbind it while we change\n      // the sink ID.\n\n\n      const existingAudioElement = this.audioElement;\n      const existingStream = this.audioStream;\n\n      if (this.browserBehavior.hasChromiumWebRTC()) {\n        existingAudioElement.srcObject = null;\n      }\n\n      if (shouldSetSinkId) {\n        try {\n          yield existingAudioElement.setSinkId(newSinkId);\n        } catch (error) {\n          (_b = this.logger) === null || _b === void 0 ? void 0 : _b.error(`Failed to set sinkId for audio element: ${error}`);\n          throw error;\n        }\n      }\n\n      if (this.browserBehavior.hasChromiumWebRTC()) {\n        existingAudioElement.srcObject = existingStream;\n      }\n    });\n  }\n\n  getCurrentMeetingAudioStream() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.audioStream;\n    });\n  }\n\n  addAudioMixObserver(observer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.observers.add(observer);\n    });\n  }\n\n  removeAudioMixObserver(observer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.observers.delete(observer);\n    });\n  }\n\n}\n\nexports.default = DefaultAudioMixController;","map":{"version":3,"mappings":"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","names":["DefaultAudioMixController","constructor","logger","DefaultBrowserBehavior_1","Set","bindAudioElement","element","Error","audioElement","autoplay","bindAudioMix","unbindAudioElement","srcObject","forEachObserver","observer","audioStream","meetingAudioStreamBecameInactive","bindAudioStream","stream","error","warn","bindAudioDevice","device","browserBehavior","supportsSetSinkId","audioDevice","observerFunc","observers","AsyncScheduler_1","nextTick","previousStream","meetingAudioStreamBecameActive","shouldSetSinkId","_a","deviceId","sinkId","newSinkId","oldSinkId","existingAudioElement","existingStream","hasChromiumWebRTC","setSinkId","_b","getCurrentMeetingAudioStream","addAudioMixObserver","add","removeAudioMixObserver","delete","exports"],"sourceRoot":"","sources":["../../src/audiomixcontroller/DefaultAudioMixController.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}