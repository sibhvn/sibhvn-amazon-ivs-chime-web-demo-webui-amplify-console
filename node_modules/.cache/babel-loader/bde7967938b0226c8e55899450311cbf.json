{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst FullJitterBackoff_1 = require(\"../backoff/FullJitterBackoff\");\n\nconst CSPMonitor_1 = require(\"../cspmonitor/CSPMonitor\");\n\nconst Message_1 = require(\"../message/Message\");\n\nconst DefaultReconnectController_1 = require(\"../reconnectcontroller/DefaultReconnectController\");\n\nconst AsyncScheduler_1 = require(\"../scheduler/AsyncScheduler\");\n\nconst DefaultSigV4_1 = require(\"../sigv4/DefaultSigV4\");\n\nconst DefaultWebSocketAdapter_1 = require(\"../websocketadapter/DefaultWebSocketAdapter\");\n\nconst WebSocketReadyState_1 = require(\"../websocketadapter/WebSocketReadyState\");\n\nclass DefaultMessagingSession {\n  constructor(configuration, logger, webSocket, reconnectController, sigV4) {\n    this.configuration = configuration;\n    this.logger = logger;\n    this.webSocket = webSocket;\n    this.reconnectController = reconnectController;\n    this.sigV4 = sigV4;\n    this.observerQueue = new Set();\n    this.isConnecting = false;\n\n    if (!this.webSocket) {\n      this.webSocket = new DefaultWebSocketAdapter_1.default(this.logger);\n    }\n\n    if (!this.reconnectController) {\n      this.reconnectController = new DefaultReconnectController_1.default(configuration.reconnectTimeoutMs, new FullJitterBackoff_1.default(configuration.reconnectFixedWaitMs, configuration.reconnectShortBackoffMs, configuration.reconnectLongBackoffMs));\n    }\n\n    if (!this.sigV4) {\n      this.sigV4 = new DefaultSigV4_1.default(this.configuration.chimeClient, this.configuration.awsClient);\n    }\n\n    CSPMonitor_1.default.addLogger(this.logger);\n    CSPMonitor_1.default.register();\n  }\n\n  addObserver(observer) {\n    this.logger.info('adding messaging observer');\n    this.observerQueue.add(observer);\n  }\n\n  removeObserver(observer) {\n    this.logger.info('removing messaging observer');\n    this.observerQueue.delete(observer);\n  }\n\n  start() {\n    if (this.isClosed() && !this.isConnecting) {\n      this.startConnecting(false);\n    } else {\n      this.logger.info('messaging session already started');\n    }\n  }\n\n  stop() {\n    if (!this.isClosed()) {\n      this.isClosing = true;\n      this.webSocket.close();\n      CSPMonitor_1.default.removeLogger(this.logger);\n    } else {\n      this.logger.info('no existing messaging session needs closing');\n    }\n  }\n\n  forEachObserver(observerFunc) {\n    for (const observer of this.observerQueue) {\n      AsyncScheduler_1.default.nextTick(() => {\n        if (this.observerQueue.has(observer)) {\n          observerFunc(observer);\n        }\n      });\n    }\n  }\n\n  setUpEventListeners() {\n    this.webSocket.addEventListener('open', () => {\n      this.openEventHandler();\n    });\n    this.webSocket.addEventListener('message', event => {\n      this.receiveMessageHandler(event.data);\n    });\n    this.webSocket.addEventListener('close', event => {\n      this.closeEventHandler(event);\n    });\n    this.webSocket.addEventListener('error', () => {\n      this.logger.error(`WebSocket error`);\n    });\n  }\n\n  startConnecting(reconnecting) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.isConnecting = true;\n\n      try {\n        if (!reconnecting) {\n          this.reconnectController.reset();\n        }\n\n        if (this.reconnectController.hasStartedConnectionAttempt()) {\n          this.reconnectController.startedConnectionAttempt(false);\n        } else {\n          this.reconnectController.startedConnectionAttempt(true);\n        } // reconnect needs to re-resolve endpoint url, which will also refresh credentials on client if they are expired.\n\n\n        let endpointUrl = !reconnecting ? this.configuration.endpointUrl : undefined;\n\n        if (endpointUrl === undefined) {\n          try {\n            const endpoint = yield this.configuration.chimeClient.getMessagingSessionEndpoint().promise();\n            endpointUrl = endpoint.Endpoint.Url;\n          } catch (e) {\n            const closeEvent = new CloseEvent('close', {\n              wasClean: false,\n              code: 4999,\n              reason: 'Failed to getMessagingSessionEndpoint',\n              bubbles: false\n            });\n            this.closeEventHandler(closeEvent);\n            return;\n          }\n        }\n\n        const signedUrl = this.prepareWebSocketUrl(endpointUrl);\n        this.logger.info(`opening connection to ${signedUrl}`);\n        this.webSocket.create(signedUrl, [], true);\n        this.forEachObserver(observer => {\n          if (observer.messagingSessionDidStartConnecting) {\n            observer.messagingSessionDidStartConnecting(reconnecting);\n          }\n        });\n        this.setUpEventListeners();\n      } finally {\n        this.isConnecting = false;\n      }\n    });\n  }\n\n  prepareWebSocketUrl(endpointUrl) {\n    const queryParams = new Map();\n    queryParams.set('userArn', [this.configuration.userArn]);\n    queryParams.set('sessionId', [this.configuration.messagingSessionId]);\n    return this.sigV4.signURL('GET', 'wss', 'chime', endpointUrl, '/connect', '', queryParams);\n  }\n\n  isClosed() {\n    return this.webSocket.readyState() === WebSocketReadyState_1.default.None || this.webSocket.readyState() === WebSocketReadyState_1.default.Closed;\n  }\n\n  openEventHandler() {\n    this.reconnectController.reset();\n    this.isSessionEstablished = false;\n  }\n\n  receiveMessageHandler(data) {\n    try {\n      const jsonData = JSON.parse(data);\n      const messageType = jsonData.Headers['x-amz-chime-event-type'];\n      const message = new Message_1.default(messageType, jsonData.Headers, jsonData.Payload || null);\n\n      if (!this.isSessionEstablished && messageType === 'SESSION_ESTABLISHED') {\n        // Backend connects WebSocket and then either\n        // (1) Closes with WebSocket error code to reflect failure to authorize or other connection error OR\n        // (2) Sends SESSION_ESTABLISHED. SESSION_ESTABLISHED indicates that all messages and events on a channel\n        // the app instance user is a member of is guaranteed to be delivered on this WebSocket as long as the WebSocket\n        // connection stays opened.\n        this.forEachObserver(observer => {\n          if (observer.messagingSessionDidStart) {\n            observer.messagingSessionDidStart();\n          }\n        });\n        this.isSessionEstablished = true;\n      } else if (!this.isSessionEstablished) {\n        // SESSION_ESTABLISHED is not guaranteed to be the first message, and in rare conditions a message or event from\n        // a channel the member is a member of might arrive prior to SESSION_ESTABLISHED.  Because SESSION_ESTABLISHED indicates\n        // it is safe to bootstrap the user application with out any race conditions in losing events we opt to drop messages prior\n        // to SESSION_ESTABLISHED being received\n        return;\n      }\n\n      this.forEachObserver(observer => {\n        if (observer.messagingSessionDidReceiveMessage) {\n          observer.messagingSessionDidReceiveMessage(message);\n        }\n      });\n    } catch (error) {\n      this.logger.error(`Messaging parsing failed: ${error}`);\n    }\n  }\n\n  retryConnection() {\n    return this.reconnectController.retryWithBackoff(() => __awaiter(this, void 0, void 0, function* () {\n      yield this.startConnecting(true);\n    }), null);\n  }\n\n  closeEventHandler(event) {\n    this.logger.info(`WebSocket close: ${event.code} ${event.reason}`);\n\n    if (event.code !== 4999) {\n      this.webSocket.destroy();\n    }\n\n    if (!this.isClosing && this.canReconnect(event.code) && this.retryConnection()) {\n      return;\n    }\n\n    this.isClosing = false;\n\n    if (this.isSessionEstablished) {\n      this.forEachObserver(observer => {\n        if (observer.messagingSessionDidStop) {\n          observer.messagingSessionDidStop(event);\n        }\n      });\n    }\n  }\n\n  canReconnect(closeCode) {\n    // 4003 is Kicked closing event from the back end\n    return closeCode === 1001 || closeCode === 1006 || closeCode >= 1011 && closeCode <= 1014 || closeCode > 4000 && closeCode !== 4002 && closeCode !== 4003 && closeCode !== 4401;\n  }\n\n}\n\nexports.default = DefaultMessagingSession;","map":{"version":3,"mappings":"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","names":["DefaultMessagingSession","constructor","configuration","logger","webSocket","reconnectController","sigV4","Set","DefaultWebSocketAdapter_1","DefaultReconnectController_1","reconnectTimeoutMs","FullJitterBackoff_1","reconnectFixedWaitMs","reconnectShortBackoffMs","reconnectLongBackoffMs","DefaultSigV4_1","chimeClient","awsClient","CSPMonitor_1","addLogger","register","addObserver","observer","info","observerQueue","add","removeObserver","delete","start","isClosed","isConnecting","startConnecting","stop","isClosing","close","removeLogger","forEachObserver","observerFunc","AsyncScheduler_1","nextTick","has","setUpEventListeners","addEventListener","openEventHandler","event","receiveMessageHandler","data","closeEventHandler","error","reconnecting","reset","hasStartedConnectionAttempt","startedConnectionAttempt","endpointUrl","undefined","endpoint","getMessagingSessionEndpoint","promise","Endpoint","Url","e","closeEvent","CloseEvent","wasClean","code","reason","bubbles","signedUrl","prepareWebSocketUrl","create","messagingSessionDidStartConnecting","queryParams","Map","set","userArn","messagingSessionId","signURL","readyState","WebSocketReadyState_1","None","Closed","isSessionEstablished","jsonData","JSON","parse","messageType","Headers","message","Message_1","Payload","messagingSessionDidStart","messagingSessionDidReceiveMessage","retryConnection","retryWithBackoff","__awaiter","destroy","canReconnect","messagingSessionDidStop","closeCode","exports"],"sourceRoot":"","sources":["../../src/messagingsession/DefaultMessagingSession.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}