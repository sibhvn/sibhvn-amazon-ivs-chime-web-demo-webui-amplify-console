{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst MeetingSessionStatus_1 = require(\"../meetingsession/MeetingSessionStatus\");\n\nconst MeetingSessionStatusCode_1 = require(\"../meetingsession/MeetingSessionStatusCode\");\n\nconst MeetingSessionTURNCredentials_1 = require(\"../meetingsession/MeetingSessionTURNCredentials\");\n\nconst SignalingClientEventType_1 = require(\"../signalingclient/SignalingClientEventType\");\n\nconst SignalingClientJoin_1 = require(\"../signalingclient/SignalingClientJoin\");\n\nconst SignalingProtocol_js_1 = require(\"../signalingprotocol/SignalingProtocol.js\");\n\nconst BaseTask_1 = require(\"./BaseTask\");\n/*\n * [[JoinAndReceiveIndexTask]] sends the JoinFrame and asynchronously waits for the server to send the [[SdkIndexFrame]].\n * It should run with the [[TimeoutTask]] as the subtask so it can get canceled after timeout.\n */\n\n\nclass JoinAndReceiveIndexTask extends BaseTask_1.default {\n  constructor(context) {\n    super(context.logger);\n    this.context = context;\n    this.taskName = 'JoinAndReceiveIndexTask';\n    this.taskCanceler = null;\n    this.maxVideos = 25;\n  }\n\n  cancel() {\n    if (this.taskCanceler) {\n      this.taskCanceler.cancel();\n      this.taskCanceler = null;\n    }\n  }\n\n  run() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const indexFrame = yield new Promise((resolve, reject) => {\n        const context = this.context;\n        context.turnCredentials = null;\n\n        class IndexFrameInterceptor {\n          constructor(signalingClient) {\n            this.signalingClient = signalingClient;\n          }\n\n          cancel() {\n            this.signalingClient.removeObserver(this);\n            reject(new Error(`JoinAndReceiveIndexTask got canceled while waiting for SdkIndexFrame`));\n          }\n\n          handleSignalingClientEvent(event) {\n            if (event.type === SignalingClientEventType_1.default.WebSocketClosed) {\n              let message = `The signaling connection was closed with code ${event.closeCode} and reason: ${event.closeReason}`;\n              context.logger.warn(message);\n              let statusCode = MeetingSessionStatusCode_1.default.SignalingBadRequest;\n\n              if (event.closeCode === 4410) {\n                message = 'The meeting already ended.';\n                context.logger.warn(message);\n                statusCode = MeetingSessionStatusCode_1.default.MeetingEnded;\n              } else if (event.closeCode >= 4500 && event.closeCode < 4600) {\n                statusCode = MeetingSessionStatusCode_1.default.SignalingInternalServerError;\n              }\n\n              context.audioVideoController.handleMeetingSessionStatus(new MeetingSessionStatus_1.default(statusCode), new Error(message));\n              return;\n            }\n\n            if (event.type !== SignalingClientEventType_1.default.ReceivedSignalFrame) {\n              return;\n            }\n\n            if (event.message.type === SignalingProtocol_js_1.SdkSignalFrame.Type.JOIN_ACK) {\n              // @ts-ignore: force cast to SdkJoinAckFrame\n              const joinAckFrame = event.message.joinack;\n\n              if (joinAckFrame && joinAckFrame.videoSubscriptionLimit) {\n                context.videoSubscriptionLimit = joinAckFrame.videoSubscriptionLimit;\n              }\n\n              context.serverSupportsCompression = joinAckFrame === null || joinAckFrame === void 0 ? void 0 : joinAckFrame.wantsCompressedSdp;\n\n              if (joinAckFrame && joinAckFrame.turnCredentials) {\n                context.turnCredentials = new MeetingSessionTURNCredentials_1.default();\n                context.turnCredentials.username = joinAckFrame.turnCredentials.username;\n                context.turnCredentials.password = joinAckFrame.turnCredentials.password;\n                context.turnCredentials.ttl = joinAckFrame.turnCredentials.ttl;\n                context.turnCredentials.uris = joinAckFrame.turnCredentials.uris.map(uri => {\n                  return context.meetingSessionConfiguration.urls.urlRewriter(uri);\n                }).filter(uri => {\n                  return !!uri;\n                });\n              } else {\n                context.logger.error('missing TURN credentials in JoinAckFrame');\n              }\n\n              return;\n            }\n\n            if (event.message.type !== SignalingProtocol_js_1.SdkSignalFrame.Type.INDEX) {\n              return;\n            }\n\n            this.signalingClient.removeObserver(this); // @ts-ignore: force cast to SdkIndexFrame\n\n            const indexFrame = event.message.index;\n            resolve(indexFrame);\n          }\n\n        }\n\n        const interceptor = new IndexFrameInterceptor(this.context.signalingClient);\n        this.context.signalingClient.registerObserver(interceptor);\n        this.taskCanceler = interceptor; // reset SDP compression state\n\n        this.context.previousSdpAnswerAsString = '';\n        this.context.previousSdpOffer = null;\n        this.context.serverSupportsCompression = false;\n        this.context.signalingClient.join(new SignalingClientJoin_1.default(this.maxVideos, true, this.context.meetingSessionConfiguration.applicationMetadata));\n      });\n      this.context.logger.info(`received first index ${JSON.stringify(indexFrame)}`); // We currently don't bother ingesting this into the same places as `ReceiveVideoStreamIndexTask` as we synchronously attempt a first subscribe\n      // after this task completes and the state isn't quite in the right place to make it work without some refactoring. However that\n      // means that we will always have an initial subscribe without any received videos.\n\n      this.context.indexFrame = indexFrame;\n    });\n  }\n\n}\n\nexports.default = JoinAndReceiveIndexTask;","map":{"version":3,"mappings":"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","names":["JoinAndReceiveIndexTask","BaseTask_1","constructor","context","logger","cancel","taskCanceler","run","indexFrame","Promise","resolve","reject","turnCredentials","IndexFrameInterceptor","signalingClient","removeObserver","Error","handleSignalingClientEvent","event","type","SignalingClientEventType_1","WebSocketClosed","message","closeCode","closeReason","warn","statusCode","MeetingSessionStatusCode_1","SignalingBadRequest","MeetingEnded","SignalingInternalServerError","audioVideoController","handleMeetingSessionStatus","MeetingSessionStatus_1","ReceivedSignalFrame","SignalingProtocol_js_1","Type","JOIN_ACK","joinAckFrame","joinack","videoSubscriptionLimit","serverSupportsCompression","wantsCompressedSdp","MeetingSessionTURNCredentials_1","username","password","ttl","uris","map","uri","meetingSessionConfiguration","urls","urlRewriter","filter","error","INDEX","index","interceptor","registerObserver","previousSdpAnswerAsString","previousSdpOffer","join","SignalingClientJoin_1","maxVideos","applicationMetadata","info","JSON","stringify","exports"],"sourceRoot":"","sources":["../../src/task/JoinAndReceiveIndexTask.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}