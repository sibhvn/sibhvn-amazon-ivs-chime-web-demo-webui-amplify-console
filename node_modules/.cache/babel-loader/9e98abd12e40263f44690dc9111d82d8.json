{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ClientMetricReportDirection_1 = require(\"../clientmetricreport/ClientMetricReportDirection\");\n\nconst ClientMetricReportMediaType_1 = require(\"../clientmetricreport/ClientMetricReportMediaType\");\n\nconst ContentShareConstants_1 = require(\"../contentsharecontroller/ContentShareConstants\");\n\nconst LogLevel_1 = require(\"../logger/LogLevel\");\n\nconst DefaultVideoStreamIdSet_1 = require(\"../videostreamidset/DefaultVideoStreamIdSet\");\n\nconst TargetDisplaySize_1 = require(\"./TargetDisplaySize\");\n\nconst VideoPreference_1 = require(\"./VideoPreference\");\n\nconst VideoPreferences_1 = require(\"./VideoPreferences\");\n\nconst VideoPriorityBasedPolicyConfig_1 = require(\"./VideoPriorityBasedPolicyConfig\");\n/** @internal */\n\n\nclass LinkMediaStats {\n  constructor() {\n    this.bandwidthEstimateKbps = 0;\n    this.usedBandwidthKbps = 0;\n    this.packetsLost = 0;\n    this.nackCount = 0;\n    this.rttMs = 0;\n  }\n\n}\n\nclass VideoPriorityBasedPolicy {\n  constructor(logger) {\n    let videoPriorityBasedPolicyConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : VideoPriorityBasedPolicyConfig_1.default.Default;\n    this.logger = logger;\n    this.videoPriorityBasedPolicyConfig = videoPriorityBasedPolicyConfig;\n    this.shouldPauseTiles = true;\n    this.observerQueue = new Set();\n    this.pausedBwAttendeeIds = new Set();\n    this.reset();\n  }\n\n  reset() {\n    this.optimalReceiveSet = new DefaultVideoStreamIdSet_1.default();\n    this.optimalReceiveStreams = [];\n    this.optimalNonPausedReceiveStreams = [];\n    this.subscribedReceiveSet = new DefaultVideoStreamIdSet_1.default();\n    this.subscribedReceiveStreams = [];\n    this.videoPreferences = undefined;\n    this.defaultVideoPreferences = undefined;\n    this.shouldPauseTiles = true;\n    this.pausedStreamIds = new DefaultVideoStreamIdSet_1.default();\n    this.pausedBwAttendeeIds = new Set();\n    this.videoPreferencesUpdated = false;\n    this.logCount = 0;\n    this.startupPeriod = true;\n    this.usingPrevTargetRate = false;\n    this.rateProbeState = \"Not Probing\"\n    /* NotProbing */\n    ;\n    this.firstEstimateTimestamp = 0;\n    this.lastUpgradeRateKbps = 0;\n    this.timeBeforeAllowSubscribeMs = VideoPriorityBasedPolicy.MIN_TIME_BETWEEN_SUBSCRIBE_MS;\n    this.lastProbeTimestamp = Date.now();\n    this.timeBeforeAllowProbeMs = VideoPriorityBasedPolicy.MIN_TIME_BETWEEN_PROBE_MS;\n    this.downlinkStats = new LinkMediaStats();\n    this.prevDownlinkStats = new LinkMediaStats();\n    this.probeFailed = false;\n  }\n\n  bindToTileController(tileController) {\n    this.tileController = tileController;\n    this.logger.info('tileController bound');\n  } // This function allows setting preferences without the need to inherit from this class\n  // which would require not using the internal keyword\n\n\n  chooseRemoteVideoSources(preferences) {\n    var _a;\n\n    if ((_a = this.videoPreferences) === null || _a === void 0 ? void 0 : _a.equals(preferences)) {\n      return;\n    }\n\n    this.videoPreferences = preferences === null || preferences === void 0 ? void 0 : preferences.clone();\n    this.videoPreferencesUpdated = true;\n    this.logger.info(`bwe: setVideoPreferences bwe: new preferences: ${JSON.stringify(preferences)}`);\n    return;\n  }\n\n  updateIndex(videoIndex) {\n    this.videoIndex = videoIndex;\n\n    if (!this.videoPreferences) {\n      this.updateDefaultVideoPreferences();\n    }\n  }\n\n  updateDefaultVideoPreferences() {\n    const attendeeIds = new Set();\n\n    for (const stream of this.videoIndex.remoteStreamDescriptions()) {\n      attendeeIds.add(stream.attendeeId);\n    }\n\n    const prefs = VideoPreferences_1.VideoPreferences.prepare();\n    const numAttendees = attendeeIds.size;\n    let targetDisplaySize = TargetDisplaySize_1.default.High;\n\n    if (numAttendees > 8) {\n      targetDisplaySize = TargetDisplaySize_1.default.Low;\n    } else if (numAttendees > 4) {\n      targetDisplaySize = TargetDisplaySize_1.default.Medium;\n    }\n\n    for (const attendeeId of attendeeIds) {\n      prefs.add(new VideoPreference_1.default(attendeeId, 1, targetDisplaySize));\n    }\n\n    this.defaultVideoPreferences = prefs.build();\n  }\n\n  updateMetrics(clientMetricReport) {\n    if (!this.videoIndex || this.videoIndex.allStreams().empty()) {\n      return;\n    }\n\n    this.prevDownlinkStats = this.downlinkStats;\n    this.downlinkStats = new LinkMediaStats();\n    const metricReport = clientMetricReport.getObservableMetrics(); // Currently we have different stats between different browsers.\n    // availableReceiveBandwidth is the old legacy Google stat\n    // availableIncomingBitrate is the standard stat but is not available in Firefox yet so only Safari for now.\n\n    if (!isNaN(metricReport.availableIncomingBitrate)) {\n      this.downlinkStats.bandwidthEstimateKbps = metricReport.availableIncomingBitrate / 1000;\n    } else {\n      this.downlinkStats.bandwidthEstimateKbps = metricReport.availableReceiveBandwidth / 1000;\n    }\n\n    for (const ssrcStr in clientMetricReport.streamMetricReports) {\n      const ssrc = Number.parseInt(ssrcStr, 10);\n      const metrics = clientMetricReport.streamMetricReports[ssrc];\n\n      if (metrics.direction === ClientMetricReportDirection_1.default.DOWNSTREAM && metrics.mediaType === ClientMetricReportMediaType_1.default.VIDEO) {\n        // Only use video stream metrics\n        if (metrics.currentMetrics.hasOwnProperty('googNacksSent')) {\n          this.downlinkStats.nackCount += clientMetricReport.countPerSecond('googNacksSent', ssrc);\n        } else if (metrics.currentMetrics.hasOwnProperty('nackCount')) {\n          this.downlinkStats.nackCount += clientMetricReport.countPerSecond('nackCount', ssrc);\n        }\n\n        if (metrics.currentMetrics.hasOwnProperty('packetsLost')) {\n          this.downlinkStats.packetsLost += clientMetricReport.countPerSecond('packetsLost', ssrc);\n        }\n\n        if (metrics.currentMetrics.hasOwnProperty('bytesReceived')) {\n          this.downlinkStats.usedBandwidthKbps += clientMetricReport.bitsPerSecond('bytesReceived', ssrc) / 1000;\n        }\n      }\n    }\n  }\n\n  wantsResubscribe() {\n    this.calculateOptimalReceiveSet();\n    return !this.subscribedReceiveSet.equal(this.optimalReceiveSet);\n  }\n\n  chooseSubscriptions() {\n    if (!this.subscribedReceiveSet.equal(this.optimalReceiveSet)) {\n      this.lastSubscribeTimestamp = Date.now();\n    }\n\n    this.subscribedReceiveSet = this.optimalReceiveSet.clone();\n    this.subscribedReceiveStreams = this.optimalReceiveStreams.slice();\n    return this.subscribedReceiveSet.clone();\n  }\n\n  addObserver(observer) {\n    this.observerQueue.add(observer);\n  }\n\n  removeObserver(observer) {\n    this.observerQueue.delete(observer);\n  }\n\n  forEachObserver(observerFunc) {\n    for (const observer of this.observerQueue) {\n      observerFunc(observer);\n    }\n  }\n\n  setVideoPriorityBasedPolicyConfigs(config) {\n    this.videoPriorityBasedPolicyConfig = config;\n  }\n\n  calculateOptimalReceiveStreams() {\n    var _a;\n\n    const chosenStreams = [];\n    const remoteInfos = this.videoIndex.remoteStreamDescriptions();\n\n    if (remoteInfos.length === 0 || ((_a = this.videoPreferences) === null || _a === void 0 ? void 0 : _a.isEmpty())) {\n      this.optimalReceiveStreams = [];\n      return;\n    }\n\n    const lastProbeState = this.rateProbeState;\n    this.cleanBwPausedTiles(remoteInfos);\n    this.handleAppPausedStreams(chosenStreams, remoteInfos);\n    const sameStreamChoices = this.availStreamsSameAsLast(remoteInfos);\n    const noMajorChange = !this.startupPeriod && sameStreamChoices; // If no major changes then don't allow subscribes for the allowed amount of time\n\n    if (noMajorChange && Date.now() - this.lastSubscribeTimestamp < this.timeBeforeAllowSubscribeMs) {\n      return;\n    } // Sort streams by bitrate ascending.\n\n\n    remoteInfos.sort((a, b) => {\n      if (a.maxBitrateKbps === b.maxBitrateKbps) {\n        return a.streamId - b.streamId;\n      }\n\n      return a.maxBitrateKbps - b.maxBitrateKbps;\n    }); // Convert 0 avg bitrates to max and handle special cases\n\n    for (const info of remoteInfos) {\n      if (info.avgBitrateKbps === 0 || info.avgBitrateKbps > info.maxBitrateKbps) {\n        // Content can be a special case\n        if (info.attendeeId.endsWith(ContentShareConstants_1.default.Modality) && info.maxBitrateKbps < 100) {\n          info.maxBitrateKbps = info.avgBitrateKbps;\n        } else {\n          info.avgBitrateKbps = info.maxBitrateKbps;\n        }\n      }\n    }\n\n    const rates = {\n      targetDownlinkBitrate: 0,\n      chosenTotalBitrate: 0,\n      deltaToNextUpgrade: 0\n    };\n    rates.targetDownlinkBitrate = this.determineTargetRate();\n    const numberOfParticipants = this.subscribedReceiveSet.size();\n    const currentEstimated = this.downlinkStats.bandwidthEstimateKbps; // Use videoPriorityBasedPolicyConfig to add additional delays based on network conditions\n\n    const dontAllowSubscribe = !this.videoPriorityBasedPolicyConfig.allowSubscribe(numberOfParticipants, currentEstimated);\n\n    if (this.probeFailed) {\n      // When probe failed, we set timeBeforeAllowSubscribeMs to 3x longer\n      // Since we have passed the subscribe interval now, we will try to probe again\n      this.probeFailed = false; // For the same reason above, reset time before allow subscribe to default\n\n      this.timeBeforeAllowSubscribeMs = VideoPriorityBasedPolicy.MIN_TIME_BETWEEN_SUBSCRIBE_MS;\n      if (noMajorChange && dontAllowSubscribe) return;\n    }\n\n    const upgradeStream = this.priorityPolicy(rates, remoteInfos, chosenStreams);\n    let subscriptionChoice = 0\n    /* NewOptimal */\n    ; // Look for probing or override opportunities\n\n    if (!this.startupPeriod && sameStreamChoices) {\n      if (this.rateProbeState === \"Probing\"\n      /* Probing */\n      ) {\n        subscriptionChoice = this.handleProbe(chosenStreams, rates.targetDownlinkBitrate);\n      } else if (rates.deltaToNextUpgrade !== 0) {\n        subscriptionChoice = this.maybeOverrideOrProbe(chosenStreams, rates, upgradeStream);\n      }\n    } else {\n      // If there was a change in streams to choose from, then cancel any probing or upgrades\n      this.setProbeState(\"Not Probing\"\n      /* NotProbing */\n      );\n      this.lastUpgradeRateKbps = 0;\n    }\n\n    this.prevRemoteInfos = remoteInfos;\n    this.videoPreferencesUpdated = false;\n\n    if (subscriptionChoice === 1\n    /* PreviousOptimal */\n    ) {\n      this.logger.info(`bwe: keepSameSubscriptions stats:${JSON.stringify(this.downlinkStats)}`);\n      this.prevTargetRateKbps = rates.targetDownlinkBitrate;\n      return;\n    }\n\n    if (subscriptionChoice === 2\n    /* PreProbe */\n    ) {\n      const subscribedRate = this.calculateSubscribeRate(this.preProbeNonPausedReceiveStreams);\n      this.optimalReceiveStreams = this.preProbeReceiveStreams.slice();\n      this.processBwPausedStreams(remoteInfos, this.preProbeNonPausedReceiveStreams);\n      this.logger.info('bwe: Use Pre-Probe subscription subscribedRate:' + subscribedRate);\n      return;\n    }\n\n    this.optimalNonPausedReceiveStreams = chosenStreams.slice();\n    const lastNumberPaused = this.pausedBwAttendeeIds.size;\n    this.processBwPausedStreams(remoteInfos, chosenStreams);\n\n    if (this.logger.getLogLevel() <= LogLevel_1.LogLevel.INFO && (this.logCount % 15 === 0 || this.rateProbeState !== lastProbeState || this.optimalReceiveStreams.length !== chosenStreams.length || lastNumberPaused !== this.pausedBwAttendeeIds.size)) {\n      this.logger.info(this.policyStateLogStr(remoteInfos, rates.targetDownlinkBitrate));\n      this.logCount = 0;\n    }\n\n    this.logCount++;\n    this.prevTargetRateKbps = rates.targetDownlinkBitrate;\n    this.optimalReceiveStreams = chosenStreams.slice();\n  }\n\n  calculateOptimalReceiveSet() {\n    const streamSelectionSet = new DefaultVideoStreamIdSet_1.default();\n    this.calculateOptimalReceiveStreams();\n\n    for (const stream of this.optimalReceiveStreams) {\n      streamSelectionSet.add(stream.streamId);\n    }\n\n    if (!this.optimalReceiveSet.equal(streamSelectionSet)) {\n      const subscribedRate = this.calculateSubscribeRate(this.optimalReceiveStreams);\n      this.logger.info(`bwe: new streamSelection: ${JSON.stringify(streamSelectionSet)} subscribedRate:${subscribedRate}`);\n    }\n\n    this.optimalReceiveSet = streamSelectionSet;\n  }\n\n  determineTargetRate() {\n    let targetBitrate = 0;\n    const now = Date.now(); // Startup phase handling.  During this period the estimate can be 0 or\n    // could still be slowly hunting for a steady state.  This startup ramp up\n    // can cause a series of subscribes which can be distracting. During this\n    // time just use our configured default value\n\n    if (this.downlinkStats.bandwidthEstimateKbps !== 0) {\n      if (this.firstEstimateTimestamp === 0) {\n        this.firstEstimateTimestamp = now;\n      } // handle startup state where estimator is still converging.\n\n\n      if (this.startupPeriod) {\n        // Drop out of startup period if\n        // - estimate is above default\n        // - get packet loss and have a valid estimate\n        // - startup period has expired and rate is not still increasing\n        if (this.downlinkStats.bandwidthEstimateKbps > VideoPriorityBasedPolicy.DEFAULT_BANDWIDTH_KBPS || this.downlinkStats.packetsLost > 0 || now - this.firstEstimateTimestamp > VideoPriorityBasedPolicy.STARTUP_PERIOD_MS && this.downlinkStats.bandwidthEstimateKbps <= this.prevDownlinkStats.bandwidthEstimateKbps) {\n          this.startupPeriod = false;\n          this.prevTargetRateKbps = this.downlinkStats.bandwidthEstimateKbps;\n        }\n      } // If we are in the startup period and we haven't detected any packet loss, then\n      // keep it at the default to let the estimation get to a steady state\n\n\n      if (this.startupPeriod) {\n        targetBitrate = VideoPriorityBasedPolicy.DEFAULT_BANDWIDTH_KBPS;\n      } else {\n        // We rely on our target bitrate being above what we are receiving to mark a probe as complete,\n        // however in browsers, the estimate can heavily lag behind the actual receive rate, especially when low.\n        //\n        // To mitigate this we override with the actual estimate plus some buffer if we aren't seeing packet loss.\n        if (this.rateProbeState === \"Probing\"\n        /* Probing */\n        && this.downlinkStats.usedBandwidthKbps > this.downlinkStats.bandwidthEstimateKbps && this.downlinkStats.packetsLost < VideoPriorityBasedPolicy.SPURIOUS_PACKET_LOST_THRESHOLD) {\n          this.logger.info(`bwe: In probe state, overriding estimate ${this.downlinkStats.bandwidthEstimateKbps} with actual receive bitrate ${this.downlinkStats.usedBandwidthKbps}`);\n          targetBitrate = this.downlinkStats.usedBandwidthKbps + VideoPriorityBasedPolicy.USED_BANDWIDTH_OVERRIDE_BUFFER_KBPS;\n        } else {\n          targetBitrate = this.downlinkStats.bandwidthEstimateKbps;\n        }\n      }\n    } else {\n      if (this.firstEstimateTimestamp === 0) {\n        targetBitrate = VideoPriorityBasedPolicy.DEFAULT_BANDWIDTH_KBPS;\n      } else {\n        targetBitrate = this.prevTargetRateKbps;\n      }\n    } // Estimated downlink rate can follow actual bandwidth or fall for a short period of time\n    // due to the absolute send time estimator incorrectly thinking that a delay in packets is\n    // a precursor to packet loss.  We have seen too many false positives on this, so we\n    // will ignore largish drops in the estimate if there is no packet loss\n\n\n    if (!this.startupPeriod && (this.usingPrevTargetRate && this.downlinkStats.bandwidthEstimateKbps < this.prevTargetRateKbps || this.downlinkStats.bandwidthEstimateKbps < this.prevTargetRateKbps * (100 - VideoPriorityBasedPolicy.LARGE_RATE_CHANGE_TRIGGER_PERCENT) / 100 || this.downlinkStats.bandwidthEstimateKbps < this.downlinkStats.usedBandwidthKbps * VideoPriorityBasedPolicy.LARGE_RATE_CHANGE_TRIGGER_PERCENT / 100) && this.downlinkStats.packetsLost === 0) {\n      // Set target to be the same as last\n      this.logger.debug(() => {\n        return 'bwe: ValidateRate: Using Previous rate ' + this.prevTargetRateKbps;\n      });\n      this.usingPrevTargetRate = true;\n      targetBitrate = this.prevTargetRateKbps;\n    } else {\n      this.usingPrevTargetRate = false;\n    }\n\n    return targetBitrate;\n  }\n\n  setProbeState(newState) {\n    if (this.rateProbeState === newState) {\n      return false;\n    }\n\n    const now = Date.now();\n\n    switch (newState) {\n      case \"Not Probing\"\n      /* NotProbing */\n      :\n        this.probePendingStartTimestamp = 0;\n        break;\n\n      case \"Probe Pending\"\n      /* ProbePending */\n      :\n        if (this.lastProbeTimestamp === 0 || now - this.lastProbeTimestamp > VideoPriorityBasedPolicy.MIN_TIME_BETWEEN_PROBE_MS) {\n          this.probePendingStartTimestamp = now;\n        } else {\n          // Too soon to do a probe again\n          return false;\n        }\n\n        break;\n\n      case \"Probing\"\n      /* Probing */\n      :\n        if (now - this.probePendingStartTimestamp > this.timeBeforeAllowProbeMs) {\n          this.lastProbeTimestamp = now;\n          this.preProbeReceiveStreams = this.subscribedReceiveStreams.slice();\n          this.preProbeNonPausedReceiveStreams = this.optimalNonPausedReceiveStreams; // Increase the time allowed until the next probe\n\n          this.timeBeforeAllowProbeMs = Math.min(this.timeBeforeAllowProbeMs * 2, VideoPriorityBasedPolicy.MAX_HOLD_BEFORE_PROBE_MS);\n        } else {\n          // Too soon to do probe\n          return false;\n        }\n\n        break;\n    }\n\n    this.logger.info('bwe: setProbeState to ' + newState + ' from ' + this.rateProbeState);\n    this.rateProbeState = newState;\n    return true;\n  } // Upgrade the stream id from the appropriate group or add it if it wasn't already in the list.\n  // Return the added amount of bandwidth\n\n\n  upgradeToStream(chosenStreams, upgradeStream) {\n    for (let i = 0; i < chosenStreams.length; i++) {\n      if (chosenStreams[i].groupId === upgradeStream.groupId) {\n        const diffRate = upgradeStream.avgBitrateKbps - chosenStreams[i].avgBitrateKbps;\n        this.logger.info('bwe: upgradeStream from ' + JSON.stringify(chosenStreams[i]) + ' to ' + upgradeStream);\n        this.lastUpgradeRateKbps = diffRate;\n        chosenStreams[i] = upgradeStream;\n        return diffRate;\n      }\n    } // We are adding a stream and not upgrading.\n\n\n    chosenStreams.push(upgradeStream);\n    this.lastUpgradeRateKbps = upgradeStream.avgBitrateKbps;\n    return this.lastUpgradeRateKbps;\n  } // Do specific behavior while we are currently in probing state and metrics\n  // indicate environment is still valid to do probing.\n  // Return true if the caller should not change from the previous subscriptions.\n\n\n  handleProbe(chosenStreams, targetDownlinkBitrate) {\n    // Don't allow probe to happen indefinitely\n    if (Date.now() - this.lastProbeTimestamp > VideoPriorityBasedPolicy.MAX_ALLOWED_PROBE_TIME_MS) {\n      this.logger.info(`bwe: Canceling probe due to timeout`);\n      this.setProbeState(\"Not Probing\"\n      /* NotProbing */\n      );\n      return 0\n      /* NewOptimal */\n      ;\n    }\n\n    if (this.downlinkStats.packetsLost > 0) {\n      this.logger.info(`bwe: Probe encountering packets lost:${this.downlinkStats.packetsLost}`); // See comment above `VideoPriorityBasedPolicy.SPURIOUS_PACKET_LOST_THRESHOLD`\n\n      if (this.downlinkStats.packetsLost > VideoPriorityBasedPolicy.SPURIOUS_PACKET_LOST_THRESHOLD) {\n        this.setProbeState(\"Not Probing\"\n        /* NotProbing */\n        );\n        this.logger.info(`bwe: Canceling probe due to packets lost:${this.downlinkStats.packetsLost}`);\n        this.probeFailed = true;\n        this.timeBeforeAllowSubscribeMs = Math.max(VideoPriorityBasedPolicy.MIN_TIME_BETWEEN_SUBSCRIBE_MS, this.timeBeforeAllowSubscribeMs) * 3; // packet lost indicates bad network and thus slowing down subscribing by extend delay by 3 times\n\n        return 2\n        /* PreProbe */\n        ;\n      }\n    }\n\n    const subscribedRate = this.calculateSubscribeRate(this.optimalReceiveStreams);\n\n    if (this.chosenStreamsSameAsLast(chosenStreams) || targetDownlinkBitrate > subscribedRate) {\n      this.logger.info(`bwe: Probe successful`); // If target bitrate can sustain probe rate, then probe was successful.\n\n      this.setProbeState(\"Not Probing\"\n      /* NotProbing */\n      ); // Reset the time allowed between probes since this was successful\n\n      this.timeBeforeAllowProbeMs = VideoPriorityBasedPolicy.MIN_TIME_BETWEEN_PROBE_MS;\n      return 0\n      /* NewOptimal */\n      ;\n    }\n\n    return 1\n    /* PreviousOptimal */\n    ;\n  }\n\n  maybeOverrideOrProbe(chosenStreams, rates, upgradeStream) {\n    const sameSubscriptions = this.chosenStreamsSameAsLast(chosenStreams);\n    let useLastSubscriptions = 0\n    /* NewOptimal */\n    ; // We want to minimize thrashing between between low res and high res of different\n    // participants due to avg bitrate fluctuations. If there hasn't been much of a change in estimated bandwidth\n    // and the number of streams and their max rates are the same, then reuse the previous subscription\n\n    const triggerPercent = rates.targetDownlinkBitrate > VideoPriorityBasedPolicy.LOW_BITRATE_THRESHOLD_KBPS ? VideoPriorityBasedPolicy.TARGET_RATE_CHANGE_TRIGGER_PERCENT : VideoPriorityBasedPolicy.TARGET_RATE_CHANGE_TRIGGER_PERCENT * 2;\n    const minTargetBitrateDelta = rates.targetDownlinkBitrate * triggerPercent / 100;\n    this.targetRateBaselineForDeltaCheckKbps = this.targetRateBaselineForDeltaCheckKbps !== undefined ? this.targetRateBaselineForDeltaCheckKbps : this.prevTargetRateKbps;\n\n    if (!sameSubscriptions && Math.abs(rates.targetDownlinkBitrate - this.targetRateBaselineForDeltaCheckKbps) < minTargetBitrateDelta) {\n      this.logger.info('bwe: MaybeOverrideOrProbe: Reuse last decision based on delta rate. {' + JSON.stringify(this.subscribedReceiveSet) + `}`);\n      useLastSubscriptions = 1\n      /* PreviousOptimal */\n      ;\n    } else {\n      this.targetRateBaselineForDeltaCheckKbps = rates.targetDownlinkBitrate;\n    } // If there has been packet loss, then reset to no probing state\n\n\n    if (this.downlinkStats.packetsLost > this.prevDownlinkStats.packetsLost) {\n      this.setProbeState(\"Not Probing\"\n      /* NotProbing */\n      );\n      this.lastUpgradeRateKbps = 0;\n      return useLastSubscriptions;\n    }\n\n    if (sameSubscriptions || useLastSubscriptions === 1\n    /* PreviousOptimal */\n    ) {\n      // If planned subscriptions are same as last, then either move to probe pending state\n      // or move to probing state if enough time has passed.\n      switch (this.rateProbeState) {\n        case \"Not Probing\"\n        /* NotProbing */\n        :\n          this.setProbeState(\"Probe Pending\"\n          /* ProbePending */\n          );\n          break;\n\n        case \"Probe Pending\"\n        /* ProbePending */\n        :\n          if (this.setProbeState(\"Probing\"\n          /* Probing */\n          )) {\n            this.upgradeToStream(chosenStreams, upgradeStream);\n            useLastSubscriptions = 0\n            /* NewOptimal */\n            ;\n          }\n\n          break;\n      }\n    } else {\n      this.setProbeState(\"Not Probing\"\n      /* NotProbing */\n      );\n    }\n\n    return useLastSubscriptions;\n  } // Utility function to find max rate of streams in current decision\n\n\n  calculateSubscribeRate(streams) {\n    let subscribeRate = 0;\n\n    for (const stream of streams) {\n      if (!this.pausedStreamIds.contain(stream.streamId) && !this.pausedBwAttendeeIds.has(stream.attendeeId)) {\n        subscribeRate += stream.maxBitrateKbps;\n      }\n    }\n\n    return subscribeRate;\n  }\n\n  handleAppPausedStreams(chosenStreams, remoteInfos) {\n    if (!this.tileController) {\n      this.logger.warn('tileController not found!');\n      return;\n    }\n\n    this.pausedStreamIds = new DefaultVideoStreamIdSet_1.default();\n    const remoteTiles = this.tileController.getAllRemoteVideoTiles();\n\n    for (const tile of remoteTiles) {\n      const state = tile.state();\n\n      if (state.paused && !this.pausedBwAttendeeIds.has(state.boundAttendeeId)) {\n        let j = remoteInfos.length;\n\n        while (j--) {\n          if (remoteInfos[j].attendeeId === state.boundAttendeeId) {\n            this.logger.info('bwe: removed paused attendee ' + state.boundAttendeeId + ' streamId: ' + remoteInfos[j].streamId);\n            this.pausedStreamIds.add(remoteInfos[j].streamId); // Add the stream to the selection set to keep the tile around\n\n            if (this.subscribedReceiveSet.contain(remoteInfos[j].streamId)) {\n              chosenStreams.push(remoteInfos[j]);\n            }\n\n            remoteInfos.splice(j, 1);\n          }\n        }\n      }\n    }\n  }\n\n  processBwPausedStreams(remoteInfos, chosenStreams) {\n    if (!this.tileController) {\n      this.logger.warn('tileController not found!');\n      return;\n    }\n\n    const preferences = this.getCurrentVideoPreferences();\n\n    if (preferences && this.shouldPauseTiles) {\n      const videoTiles = this.tileController.getAllVideoTiles();\n\n      for (const preference of preferences) {\n        const videoTile = this.getVideoTileForAttendeeId(preference.attendeeId, videoTiles);\n        const paused = (videoTile === null || videoTile === void 0 ? void 0 : videoTile.state().paused) || false;\n\n        if (!chosenStreams.some(stream => stream.attendeeId === preference.attendeeId)) {\n          // We cannot rely on the existance of video tile to indicate that the source exists in the call\n          // because tiles will not be added or removed until after a full renegotiation (i.e. it will\n          // be behind the state provided by the index)\n          const streamExists = remoteInfos.some(stream => stream.attendeeId === preference.attendeeId);\n\n          if (videoTile && streamExists) {\n            const info = this.optimalReceiveStreams.find(stream => stream.attendeeId === preference.attendeeId);\n\n            if (info !== undefined) {\n              if (!paused) {\n                this.logger.info(`bwe: pausing streamId ${info.streamId} attendee ${preference.attendeeId} due to bandwidth`);\n                this.forEachObserver(observer => {\n                  observer.tileWillBePausedByDownlinkPolicy(videoTile.id());\n                });\n                this.tileController.pauseVideoTile(videoTile.id());\n              }\n\n              chosenStreams.push(info);\n            }\n\n            this.pausedBwAttendeeIds.add(preference.attendeeId);\n          } else if (streamExists) {\n            // Create a tile for this participant if one doesn't already exist and mark it as paused\n            // Don't include it in the chosen streams because we don't want to subscribe for it then have to pause it.\n            const newTile = this.tileController.addVideoTile();\n            newTile.bindVideoStream(preference.attendeeId, false, null, 0, 0, 0, null);\n            this.forEachObserver(observer => {\n              observer.tileWillBePausedByDownlinkPolicy(newTile.id());\n            });\n            newTile.pause();\n            this.logger.info(`bwe: Created video tile ${newTile.id()} for bw paused attendee ${preference.attendeeId}`);\n            this.pausedBwAttendeeIds.add(preference.attendeeId);\n          }\n        } else if (paused && this.pausedBwAttendeeIds.has(preference.attendeeId)) {\n          this.logger.info(`bwe: unpausing attendee ${preference.attendeeId} due to bandwidth`);\n          this.forEachObserver(observer => {\n            observer.tileWillBeUnpausedByDownlinkPolicy(videoTile.id());\n          });\n          this.tileController.unpauseVideoTile(videoTile.id());\n          this.pausedBwAttendeeIds.delete(preference.attendeeId);\n        }\n      }\n    }\n  }\n\n  cleanBwPausedTiles(remoteInfos) {\n    if (!this.tileController) {\n      this.logger.warn('tileController not found!');\n      return;\n    }\n\n    const tiles = this.tileController.getAllRemoteVideoTiles();\n    const preferences = this.getCurrentVideoPreferences();\n\n    for (const tile of tiles) {\n      const state = tile.state();\n\n      if (!state.boundVideoStream) {\n        if (!remoteInfos.some(stream => stream.attendeeId === state.boundAttendeeId)) {\n          this.tileController.removeVideoTile(state.tileId);\n          this.logger.info(`bwe: Removed video tile ${state.tileId} for bw paused attendee ${state.boundAttendeeId}`);\n        } else if (preferences !== undefined && !preferences.some(pref => pref.attendeeId === state.boundAttendeeId)) {\n          this.tileController.removeVideoTile(state.tileId);\n        }\n      }\n    }\n  }\n\n  priorityPolicy(rates, remoteInfos, chosenStreams) {\n    let upgradeStream;\n    const videoPreferences = this.getCurrentVideoPreferences();\n    const highestPriority = videoPreferences.highestPriority();\n    let nextPriority;\n    let priority = highestPriority;\n\n    while (priority !== -1) {\n      nextPriority = -1;\n\n      for (const preference of videoPreferences) {\n        if (preference.priority === priority) {\n          // First subscribe to at least low rate\n          for (const info of remoteInfos) {\n            if (info.attendeeId === preference.attendeeId) {\n              if (!chosenStreams.some(stream => stream.groupId === info.groupId)) {\n                if (rates.chosenTotalBitrate + info.avgBitrateKbps <= rates.targetDownlinkBitrate) {\n                  chosenStreams.push(info);\n                  rates.chosenTotalBitrate += info.avgBitrateKbps;\n                } else if (rates.deltaToNextUpgrade === 0) {\n                  // Keep track of step to next upgrade\n                  rates.deltaToNextUpgrade = info.avgBitrateKbps;\n                  upgradeStream = info;\n                }\n              }\n            }\n          }\n        } else {\n          if (preference.priority > priority) {\n            nextPriority = preference.priority;\n            break;\n          }\n        }\n      } // Now try to upgrade all attendee's with this priority\n\n\n      for (const preference of videoPreferences) {\n        if (preference.priority === priority) {\n          for (const info of remoteInfos) {\n            if (info.attendeeId === preference.attendeeId) {\n              const index = chosenStreams.findIndex(stream => stream.groupId === info.groupId && stream.maxBitrateKbps < info.maxBitrateKbps);\n\n              if (index !== -1) {\n                const increaseKbps = info.avgBitrateKbps - chosenStreams[index].avgBitrateKbps;\n\n                if (this.hasSimulcastStreams(remoteInfos, info.attendeeId, info.groupId) && this.canUpgrade(info.avgBitrateKbps, preference.targetSizeToBitrateKbps(preference.targetSize))) {\n                  this.logger.info(`bwe: attendee: ${info.attendeeId} group: ${info.groupId} has simulcast and can upgrade avgBitrate: ${info.avgBitrateKbps} target: ${preference.targetSizeToBitrateKbps(preference.targetSize)} targetTotalBitrate: ${rates.targetDownlinkBitrate}`);\n\n                  if (rates.chosenTotalBitrate + increaseKbps <= rates.targetDownlinkBitrate) {\n                    rates.chosenTotalBitrate += increaseKbps;\n                    chosenStreams[index] = info;\n                  } else if (rates.deltaToNextUpgrade === 0) {\n                    // Keep track of step to next upgrade\n                    rates.deltaToNextUpgrade = increaseKbps;\n                    upgradeStream = info;\n                  }\n                } else {\n                  this.logger.info('bwe: cannot upgrade stream quality beyond target size');\n                }\n              }\n            }\n          }\n        } else {\n          if (preference.priority > priority) {\n            break;\n          }\n        }\n      } // If we haven't subscribed to the highest rate of the top priority videos then\n      // do not subscribe to any other sources\n\n\n      if (priority === highestPriority && rates.deltaToNextUpgrade !== 0) {\n        break;\n      }\n\n      priority = nextPriority;\n    }\n\n    return upgradeStream;\n  }\n\n  getVideoTileForAttendeeId(attendeeId, videoTiles) {\n    for (const tile of videoTiles) {\n      const state = tile.state();\n\n      if (state.boundAttendeeId === attendeeId) {\n        return tile;\n      }\n    }\n\n    return null;\n  }\n\n  canUpgrade(bitrateKbp, targetBitrateKbp) {\n    if (bitrateKbp <= targetBitrateKbp) {\n      this.logger.info(`bwe: canUpgrade: bitrateKbp: ${bitrateKbp} targetBitrateKbp: ${targetBitrateKbp}`);\n      return true;\n    }\n\n    this.logger.info(`bwe: cannot Upgrade: bitrateKbp: ${bitrateKbp} targetBitrateKbp: ${targetBitrateKbp}`);\n    return false;\n  }\n\n  hasSimulcastStreams(remoteInfos, attendeeId, groupId) {\n    let streamCount = 0;\n\n    for (const info of remoteInfos) {\n      if (info.attendeeId === attendeeId && info.groupId === groupId) {\n        streamCount++;\n      }\n    }\n\n    this.logger.info(`bwe: attendeeId: ${attendeeId} groupId: ${groupId} hasSimulcastStreams: streamCount: ${streamCount}`);\n    return streamCount > 1;\n  }\n\n  availStreamsSameAsLast(remoteInfos) {\n    if (this.prevRemoteInfos === undefined || remoteInfos.length !== this.prevRemoteInfos.length || this.videoPreferencesUpdated === true) {\n      return false;\n    }\n\n    for (const info of remoteInfos) {\n      const infoMatch = this.prevRemoteInfos.find(prevInfo => prevInfo.groupId === info.groupId && prevInfo.streamId === info.streamId && prevInfo.maxBitrateKbps === info.maxBitrateKbps);\n\n      if (infoMatch === undefined) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  chosenStreamsSameAsLast(chosenStreams) {\n    if (this.optimalNonPausedReceiveStreams.length !== chosenStreams.length) {\n      return false;\n    }\n\n    for (const lastStream of this.optimalNonPausedReceiveStreams) {\n      if (!chosenStreams.some(stream => stream.streamId === lastStream.streamId)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  policyStateLogStr(remoteInfos, targetDownlinkBitrate) {\n    const subscribedRate = this.calculateSubscribeRate(this.optimalReceiveStreams);\n    const optimalReceiveSet = {\n      targetBitrate: targetDownlinkBitrate,\n      subscribedRate: subscribedRate,\n      probeState: this.rateProbeState,\n      startupPeriod: this.startupPeriod\n    }; // Reduced remote info logging:\n\n    let remoteInfoStr = `remoteInfos: [`;\n\n    for (const info of remoteInfos) {\n      remoteInfoStr += `{grpId:${info.groupId} strId:${info.streamId} maxBr:${info.maxBitrateKbps} avgBr:${info.avgBitrateKbps}}, `;\n    }\n\n    remoteInfoStr += `]`;\n    let logString = `bwe: optimalReceiveSet ${JSON.stringify(optimalReceiveSet)}\\n` + `bwe:   prev ${JSON.stringify(this.prevDownlinkStats)}\\n` + `bwe:   now  ${JSON.stringify(this.downlinkStats)}\\n` + `bwe:   ${remoteInfoStr}\\n`;\n\n    if (this.pausedStreamIds.size() > 0 || this.pausedBwAttendeeIds.size > 0) {\n      logString += `bwe:   paused: app stream ids ${JSON.stringify(this.pausedStreamIds)}  bw attendees { ${Array.from(this.pausedBwAttendeeIds).join(' ')} }\\n`;\n    }\n\n    if (this.videoPreferences) {\n      logString += `bwe:   preferences: ${JSON.stringify(this.videoPreferences)}`;\n    } else {\n      logString += `bwe:   default preferences: ${JSON.stringify(this.defaultVideoPreferences)}`;\n    }\n\n    return logString;\n  }\n\n  getCurrentVideoPreferences() {\n    return this.videoPreferences || this.defaultVideoPreferences;\n  }\n\n}\n\nexports.default = VideoPriorityBasedPolicy;\nVideoPriorityBasedPolicy.DEFAULT_BANDWIDTH_KBPS = 2800;\nVideoPriorityBasedPolicy.STARTUP_PERIOD_MS = 6000;\nVideoPriorityBasedPolicy.LARGE_RATE_CHANGE_TRIGGER_PERCENT = 20;\nVideoPriorityBasedPolicy.TARGET_RATE_CHANGE_TRIGGER_PERCENT = 15;\nVideoPriorityBasedPolicy.LOW_BITRATE_THRESHOLD_KBPS = 300;\nVideoPriorityBasedPolicy.MIN_TIME_BETWEEN_PROBE_MS = 5000;\nVideoPriorityBasedPolicy.MIN_TIME_BETWEEN_SUBSCRIBE_MS = 2000; // We apply exponentional backoff to probe attempts if they do not\n// succeed, so we need to set a reasonable maximum.\n\nVideoPriorityBasedPolicy.MAX_HOLD_BEFORE_PROBE_MS = 30000;\nVideoPriorityBasedPolicy.MAX_ALLOWED_PROBE_TIME_MS = 60000; // Occasionally we see that on unpause or upgrade we see a single packet lost\n// or two, even in completely unconstrained scenarios. We should look into\n// why this occurs on the backend, but for now we require a non-trivial\n// amount of packets lost to fail the probe. These could also be from\n// other senders given we don't yet use TWCC.\n\nVideoPriorityBasedPolicy.SPURIOUS_PACKET_LOST_THRESHOLD = 2; // See usage\n\nVideoPriorityBasedPolicy.USED_BANDWIDTH_OVERRIDE_BUFFER_KBPS = 100;","map":{"version":3,"mappings":"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","names":["LinkMediaStats","constructor","VideoPriorityBasedPolicy","logger","videoPriorityBasedPolicyConfig","VideoPriorityBasedPolicyConfig_1","Default","Set","reset","optimalReceiveSet","DefaultVideoStreamIdSet_1","optimalReceiveStreams","optimalNonPausedReceiveStreams","subscribedReceiveSet","subscribedReceiveStreams","videoPreferences","undefined","defaultVideoPreferences","shouldPauseTiles","pausedStreamIds","pausedBwAttendeeIds","videoPreferencesUpdated","logCount","startupPeriod","usingPrevTargetRate","rateProbeState","firstEstimateTimestamp","lastUpgradeRateKbps","timeBeforeAllowSubscribeMs","MIN_TIME_BETWEEN_SUBSCRIBE_MS","lastProbeTimestamp","Date","now","timeBeforeAllowProbeMs","MIN_TIME_BETWEEN_PROBE_MS","downlinkStats","prevDownlinkStats","probeFailed","bindToTileController","tileController","info","chooseRemoteVideoSources","preferences","_a","equals","clone","JSON","stringify","updateIndex","videoIndex","updateDefaultVideoPreferences","attendeeIds","stream","remoteStreamDescriptions","add","attendeeId","prefs","VideoPreferences_1","prepare","numAttendees","size","targetDisplaySize","TargetDisplaySize_1","High","Low","Medium","VideoPreference_1","build","updateMetrics","clientMetricReport","allStreams","empty","metricReport","getObservableMetrics","isNaN","availableIncomingBitrate","bandwidthEstimateKbps","availableReceiveBandwidth","ssrcStr","streamMetricReports","ssrc","Number","parseInt","metrics","direction","ClientMetricReportDirection_1","DOWNSTREAM","mediaType","ClientMetricReportMediaType_1","VIDEO","currentMetrics","hasOwnProperty","nackCount","countPerSecond","packetsLost","usedBandwidthKbps","bitsPerSecond","wantsResubscribe","calculateOptimalReceiveSet","equal","chooseSubscriptions","lastSubscribeTimestamp","slice","addObserver","observer","observerQueue","removeObserver","delete","forEachObserver","observerFunc","setVideoPriorityBasedPolicyConfigs","config","calculateOptimalReceiveStreams","chosenStreams","remoteInfos","length","isEmpty","lastProbeState","cleanBwPausedTiles","handleAppPausedStreams","sameStreamChoices","availStreamsSameAsLast","noMajorChange","sort","a","b","maxBitrateKbps","streamId","avgBitrateKbps","endsWith","ContentShareConstants_1","Modality","rates","targetDownlinkBitrate","chosenTotalBitrate","deltaToNextUpgrade","determineTargetRate","numberOfParticipants","currentEstimated","dontAllowSubscribe","allowSubscribe","upgradeStream","priorityPolicy","subscriptionChoice","handleProbe","maybeOverrideOrProbe","setProbeState","prevRemoteInfos","prevTargetRateKbps","subscribedRate","calculateSubscribeRate","preProbeNonPausedReceiveStreams","preProbeReceiveStreams","processBwPausedStreams","lastNumberPaused","getLogLevel","LogLevel_1","INFO","policyStateLogStr","streamSelectionSet","targetBitrate","DEFAULT_BANDWIDTH_KBPS","STARTUP_PERIOD_MS","SPURIOUS_PACKET_LOST_THRESHOLD","USED_BANDWIDTH_OVERRIDE_BUFFER_KBPS","LARGE_RATE_CHANGE_TRIGGER_PERCENT","debug","newState","probePendingStartTimestamp","Math","min","MAX_HOLD_BEFORE_PROBE_MS","upgradeToStream","i","groupId","diffRate","push","MAX_ALLOWED_PROBE_TIME_MS","max","chosenStreamsSameAsLast","sameSubscriptions","useLastSubscriptions","triggerPercent","LOW_BITRATE_THRESHOLD_KBPS","TARGET_RATE_CHANGE_TRIGGER_PERCENT","minTargetBitrateDelta","targetRateBaselineForDeltaCheckKbps","abs","streams","subscribeRate","contain","has","warn","remoteTiles","getAllRemoteVideoTiles","tile","state","paused","boundAttendeeId","j","splice","getCurrentVideoPreferences","videoTiles","getAllVideoTiles","preference","videoTile","getVideoTileForAttendeeId","some","streamExists","find","tileWillBePausedByDownlinkPolicy","id","pauseVideoTile","newTile","addVideoTile","bindVideoStream","pause","tileWillBeUnpausedByDownlinkPolicy","unpauseVideoTile","tiles","boundVideoStream","removeVideoTile","tileId","pref","highestPriority","nextPriority","priority","index","findIndex","increaseKbps","hasSimulcastStreams","canUpgrade","targetSizeToBitrateKbps","targetSize","bitrateKbp","targetBitrateKbp","streamCount","infoMatch","prevInfo","lastStream","probeState","remoteInfoStr","logString","Array","from","join","exports"],"sourceRoot":"","sources":["../../src/videodownlinkbandwidthpolicy/VideoPriorityBasedPolicy.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}