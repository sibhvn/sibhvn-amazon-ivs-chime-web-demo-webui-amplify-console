{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst FullJitterBackoff_1 = require(\"../backoff/FullJitterBackoff\");\n\nconst IntervalScheduler_1 = require(\"../scheduler/IntervalScheduler\");\n\nconst DefaultUserAgentParser_1 = require(\"../useragentparser/DefaultUserAgentParser\");\n\nconst Utils_1 = require(\"../utils/Utils\");\n/**\n * [[InMemoryJSONEventBuffer]] is an in-memory implementation for buffering and\n * sending events. It buffers events based on number of events and its size whichever reaches\n * first. Events are sent out at an scheduled interval where important events are sent immediately.\n * It also retries sending events if failed upto the retry count limit. It implements\n * beaconing mechanism based on 'pagehide' and 'visibilitychange' to beacon all events as a last attempt.\n */\n\n\nclass InMemoryJSONEventBuffer {\n  constructor(eventBufferConfiguration, eventsClientConfiguration, ingestionURL, importantEvents, logger) {\n    this.buffer = [];\n    this.bufferSize = 0;\n    this.maxBufferItemCapacityBytes = 0;\n    this.ingestionEventSize = 0;\n    this.flushIntervalMs = 0;\n    this.flushSize = 0;\n    this.failedIngestionEvents = [];\n    this.retryCountLimit = 15;\n    this.lock = false;\n    this.cancellableEvents = new Map();\n    this.attributesToFilter = ['externalUserId', 'externalMeetingId', 'timestampMs'];\n\n    this.deepCopyCurrentIngestionEvent = event => {\n      const newEvent = {\n        type: event.type,\n        v: event.v,\n        payloads: [...event.payloads]\n      };\n      return newEvent;\n    };\n\n    this.sendEvents = () => __awaiter(this, void 0, void 0, function* () {\n      if (this.lock) {\n        return;\n      }\n\n      const batch = this.getItems(this.flushSize);\n\n      if (batch.length === 0) {\n        return;\n      }\n\n      this.lock = true;\n      const body = this.makeRequestBody(batch);\n      let failed = false; // If a page re-directs, in Safari and Chrome, the network\n      // request shows cancelled but the data reaches the ingestion endpoint.\n      // In Firefox, the request errors out with 'NS_BINDING_ABORT' state. Hence, add the event\n      // to cancellable events to try with `sendBeacon` lastly.\n\n      const timestamp = Date.now();\n\n      if (this.metadata.browserName.toLowerCase() === 'firefox') {\n        this.cancellableEvents.set(timestamp, batch);\n      }\n\n      try {\n        this.logger.debug(`Event Reporting - InMemoryJSONEventBuffer - sendEvents - sending body ${body}`);\n        const response = yield this.send(body);\n        this.cancellableEvents.delete(timestamp);\n\n        if (!response.ok) {\n          this.logger.error(`Event Reporting - InMemoryJSONEventBuffer - sendEvents - Failed to send events ${body} with response status ${response.status}`);\n          failed = true;\n        } else {\n          try {\n            const data = yield response.json();\n            this.logger.debug(`Event Reporting - InMemoryJSONEventBuffer - sendEvents - send successful events: ${body} message: ${JSON.stringify(data)}`);\n          } catch (err) {\n            /* istanbul ignore next */\n            this.logger.warn(`Event Reporting - InMemoryJSONEventBuffer - sendEvents error reading OK response ${err} for events ${body}`);\n          }\n        }\n      } catch (error) {\n        failed = true;\n        this.logger.warn(`Event Reporting - InMemoryJSONEventBuffer - sendEvents - Error in sending events ${body} to the ingestion endpoint ${error}`);\n      } finally {\n        this.lock = false;\n      }\n\n      if (failed) {\n        this.cancellableEvents.delete(timestamp);\n        this.failedIngestionEvents.push(...batch);\n      }\n    });\n\n    const userAgentParserResult = new DefaultUserAgentParser_1.default(logger).getParserResult();\n\n    const {\n      browserMajorVersion: _browserMajorVersion\n    } = userAgentParserResult,\n          clientMetadata = __rest(userAgentParserResult, [\"browserMajorVersion\"]);\n\n    const _a = eventsClientConfiguration.toJSON(),\n          {\n      type,\n      v\n    } = _a,\n          rest = __rest(_a, [\"type\", \"v\"]);\n\n    this.authenticationToken = eventsClientConfiguration.getAuthenticationToken();\n    this.metadata = Object.assign(Object.assign({}, clientMetadata), rest);\n    Object.keys(this.metadata).forEach(key => this.attributesToFilter.push(key));\n    this.type = type;\n    this.v = v;\n    this.ingestionURL = ingestionURL;\n    this.logger = logger;\n    this.importantEvents = new Set(importantEvents);\n    const {\n      maxBufferCapacityKb,\n      totalBufferItems,\n      flushSize,\n      flushIntervalMs,\n      retryCountLimit\n    } = eventBufferConfiguration;\n    this.maxBufferCapacityBytes = maxBufferCapacityKb * 1024;\n    this.totalBufferItems = totalBufferItems;\n    this.maxBufferItemCapacityBytes = Math.round(this.maxBufferCapacityBytes / totalBufferItems);\n    this.flushIntervalMs = flushIntervalMs;\n    this.flushSize = flushSize;\n    this.retryCountLimit = retryCountLimit;\n    this.currentIngestionEvent = this.initializeAndGetCurrentIngestionEvent();\n\n    this.beaconEventListener = e => this.beaconEventHandler(e);\n\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    if (!this.beaconEventListener || !('window' in global) || !window.addEventListener || !('document' in global) || !document.addEventListener) {\n      return;\n    }\n\n    this.logger.debug(`Event Reporting - InMemoryJSONEventBuffer - addEventListeners - adding pagehide and visibility change event listeners`);\n    window.addEventListener('pagehide', this.beaconEventListener);\n    document.addEventListener('visibilitychange', this.beaconEventListener);\n  }\n\n  beaconEventHandler(e) {\n    /* istanbul ignore else */\n    if (e.type === 'visibilitychange' && document.visibilityState === 'hidden' || e.type === 'pagehide') {\n      this.logger.debug(`Event Reporting - InMemoryJSONEventBuffer - beaconEventHandler is triggered calling sendBeacon`);\n      this.sendBeacon();\n    }\n  }\n\n  removeEventListeners() {\n    if (!this.beaconEventListener || !('window' in global) || !window.removeEventListener || !('document' in global) || !document.removeEventListener) {\n      return;\n    }\n\n    window.removeEventListener('pagehide', this.beaconEventListener);\n    document.removeEventListener('visibilitychange', this.beaconEventListener);\n    this.logger.debug(`Event Reporting - InMemoryJSONEventBuffer - removeEventListeners - removing pagehide and visibility change event listeners`);\n  }\n\n  start() {\n    var _a;\n\n    this.removeEventListeners();\n    this.addEventListeners();\n    (_a = this.intervalScheduler) === null || _a === void 0 ? void 0 : _a.stop();\n    this.intervalScheduler = new IntervalScheduler_1.default(this.flushIntervalMs);\n    this.intervalScheduler.start(() => this.sendEvents());\n  }\n\n  stop() {\n    var _a;\n\n    (_a = this.intervalScheduler) === null || _a === void 0 ? void 0 : _a.stop();\n    this.intervalScheduler = undefined;\n    this.sendBeacon();\n    this.removeEventListeners();\n  }\n\n  addItem(item) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.logger.debug(`Event Reporting - InMemoryJSONEventBuffer - addItem - received event ${JSON.stringify(item)}`);\n      const {\n        name,\n        ts,\n        attributes\n      } = item; // Filter out PII and redundant attributes.\n\n      const filteredAttributes = attributes && this.filterAttributes(attributes, this.attributesToFilter);\n      const event = Object.assign({\n        name,\n        ts\n      }, filteredAttributes);\n      this.logger.debug(`Event Reporting - InMemoryJSONEventBuffer - addItem - event after filtering attributes ${JSON.stringify(event)}`);\n      const size = this.getSize(event);\n\n      if (size > InMemoryJSONEventBuffer.MAX_ITEM_SIZE_BYTES_ALLOWED) {\n        throw new Error(`Event Reporting - Item to be added has size ${size} bytes. Item cannot exceed max item size allowed of ${InMemoryJSONEventBuffer.MAX_ITEM_SIZE_BYTES_ALLOWED} bytes.`);\n      }\n\n      if (this.importantEvents.has(name)) {\n        // Send immediate events and asyncly retry.\n        this.logger.debug(`Event Reporting - InMemoryJSONEventBuffer - addItem - sending important event ${JSON.stringify(event)}`);\n        this.sendEventImmediately({\n          name,\n          ts,\n          attributes: filteredAttributes\n        });\n        return;\n      }\n\n      if (this.isFull()) {\n        this.logger.warn('Event Reporting - Event buffer is full');\n        throw new Error('Buffer full');\n      }\n\n      this.currentIngestionEvent.payloads.push(event);\n      this.ingestionEventSize += size;\n\n      if (this.bufferItemThresholdReached(size)) {\n        const currentEvent = this.deepCopyCurrentIngestionEvent(this.currentIngestionEvent);\n        this.buffer.push(currentEvent);\n        this.bufferSize += this.ingestionEventSize;\n        this.currentIngestionEvent = this.initializeAndGetCurrentIngestionEvent();\n        this.logger.debug(`Event Reporting - InMemoryJSONEventBuffer - addItem - buffer item threshold reached updated buffer ${JSON.stringify(this.buffer)}`);\n      }\n    });\n  }\n\n  filterAttributes(attributes, attributesToFilter) {\n    const attributesToFilterSet = new Set(attributesToFilter);\n    const keysToFilterOut = Object.keys(attributes).filter(key => attributesToFilterSet.has(key));\n    keysToFilterOut.forEach(key => delete attributes[key]);\n    return attributes;\n  }\n\n  initializeAndGetCurrentIngestionEvent() {\n    const bufferItem = {\n      type: this.type,\n      v: this.v,\n      payloads: []\n    };\n    this.ingestionEventSize = this.getSize(bufferItem);\n    return bufferItem;\n  }\n\n  bufferItemThresholdReached(size) {\n    return size + this.ingestionEventSize >= this.maxBufferItemCapacityBytes || this.currentIngestionEvent.payloads.length === InMemoryJSONEventBuffer.MAX_PAYLOAD_ITEMS;\n  }\n\n  getSize(item) {\n    let bytes = 0;\n\n    if (typeof item === 'object') {\n      for (const [key, value] of Object.entries(item)) {\n        bytes += this.getPrimitiveSize(key);\n        bytes += this.getSize(value);\n      }\n    } else {\n      bytes += this.getPrimitiveSize(item);\n    }\n\n    return bytes;\n  }\n\n  getPrimitiveSize(item) {\n    let bytes = 0;\n    /* istanbul ignore else */\n\n    if (typeof item === 'string') {\n      bytes += item.length * 2;\n    } else if (typeof item === 'number') {\n      bytes += 8;\n    }\n\n    return bytes;\n  }\n\n  isFull() {\n    return this.bufferSize === this.maxBufferCapacityBytes || this.buffer.length === this.totalBufferItems;\n  }\n\n  isEmpty() {\n    return this.buffer.length === 0 || this.bufferSize === 0;\n  }\n\n  getItems(end) {\n    let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    if (this.isEmpty()) {\n      return [];\n    }\n\n    end = Math.min(this.buffer.length, end + 1);\n    const items = this.buffer.splice(start, end);\n    return items;\n  }\n\n  makeBeaconRequestBody(batchEvents) {\n    const ingestionRecord = {\n      metadata: this.metadata,\n      events: batchEvents,\n      authorization: this.authenticationToken\n    };\n    return JSON.stringify(ingestionRecord);\n  }\n\n  makeRequestBody(batchEvents) {\n    const ingestionRecord = {\n      metadata: this.metadata,\n      events: batchEvents\n    };\n    return JSON.stringify(ingestionRecord);\n  }\n\n  sendEventImmediately(item) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.logger.debug(`Event Reporting - InMemoryJSONEventBuffer - sendEventImmediately - important event received ${JSON.stringify(item)}`);\n      const {\n        name,\n        ts,\n        attributes\n      } = item;\n      const event = {\n        type: this.type,\n        v: this.v,\n        payloads: [Object.assign({\n          name,\n          ts\n        }, attributes)]\n      };\n      let failed = false;\n      let response = null;\n      const body = this.makeRequestBody([event]);\n\n      try {\n        response = yield this.send(body);\n\n        if (response.ok) {\n          try {\n            const data = yield response.json();\n            this.logger.debug(`Event Reporting - InMemoryJSONEventBuffer - sendEventImmediately - send successful event: ${body}, message: ${JSON.stringify(data)}`);\n          } catch (err) {\n            /* istanbul ignore next */\n            this.logger.warn(`Event Reporting - InMemoryJSONEventBuffer - sendEventImmediately - Error reading OK response ${err} for event ${body}`);\n          }\n\n          return;\n        } else {\n          this.logger.error(`Event Reporting - InMemoryJSONEventBuffer - sendEventImmediately - Failed to send an important event ${body} with response status ${response.status}`);\n          failed = true;\n        }\n      } catch (error) {\n        this.logger.warn(`Event Reporting - There may be a failure in sending an important event ${body} to the ingestion endpoint ${error}.`);\n        failed = true;\n\n        try {\n          /**\n           * Important events like meetingEnded, meetingStartFailed may result into page-redirects.\n           * In such a case, Firefox aborts the fetch request with 'NS_BINDING_ABORT' state.\n           * Chrome and Safari show fetch request as cancelled and the fetch failure is catched, but,\n           * events appear at ingestion backend. Chrome and Safari behavior is unreliable, but Firefox consistently fails,\n           * hence, we beacon data as a last resort when using Firefox.\n           * During the page-redirect, we do not have access to check fetch's response to handle Chrome and Safari behavior,\n           * hence, event ingestion may fail.\n           *\n           */\n          if (this.metadata.browserName.toLowerCase() === 'firefox') {\n            const body = this.makeBeaconRequestBody([event]);\n            this.logger.debug(`Event Reporting - InMemoryJSONEventBuffer - sendEventImmediately - beaconing data out ${body}`);\n\n            if (!navigator.sendBeacon(`${this.ingestionURL}?beacon=1`, body)) {\n              failed = true;\n            } else {\n              failed = false;\n            }\n          }\n        } catch (error) {\n          this.logger.warn(`Event Reporting - Error sending beacon for an important event ${body}`);\n          failed = true;\n        }\n      }\n      /* istanbul ignore else */\n\n\n      if (failed) {\n        this.logger.debug(`Event Reporting - InMemoryJSONEventBuffer - sendEventImmediately - pushing to failed events ${body}`);\n        this.failedIngestionEvents.push(event);\n      }\n    });\n  }\n\n  send(data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const backoff = new FullJitterBackoff_1.default(InMemoryJSONEventBuffer.RETRY_FIXED_BACKOFF_WAIT_MS, InMemoryJSONEventBuffer.RETRY_SHORT_BACKOFF_MS, InMemoryJSONEventBuffer.RETRY_LONG_BACKOFF_MS);\n\n      try {\n        let retryCount = 0;\n\n        while (retryCount < this.retryCountLimit) {\n          const response = yield fetch(this.ingestionURL, {\n            method: 'POST',\n            headers: {\n              Authorization: `Bearer ${this.authenticationToken}`\n            },\n            body: data\n          });\n\n          if (response.ok || !InMemoryJSONEventBuffer.SENDING_FAILURE_CODES.has(response.status)) {\n            return response;\n          } else {\n            this.logger.warn(`Will retry sending failure for ${data} due to status code ${response.status}.`);\n            retryCount++;\n            /* istanbul ignore else */\n\n            if (retryCount < this.retryCountLimit) {\n              const backoffTime = backoff.nextBackoffAmountMs();\n              yield Utils_1.wait(backoffTime);\n            }\n          }\n        }\n        /* istanbul ignore else */\n\n\n        if (retryCount === this.retryCountLimit) {\n          throw new Error(`Retry count limit reached for ${data}`);\n        }\n      } catch (error) {\n        throw error;\n      }\n    });\n  }\n\n  sendBeacon() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Any pending events from buffer.\n      const events = this.buffer;\n      this.logger.debug(`Event Reporting - InMemoryJSONEventBuffer - sendBeacon - clearing out buffer events ${JSON.stringify(events)}`);\n      this.buffer = []; // Any pending event in current ingestion event.\n\n      if (this.currentIngestionEvent.payloads.length > 0) {\n        const clearCurrenIngestionEvent = this.deepCopyCurrentIngestionEvent(this.currentIngestionEvent);\n        events.push(clearCurrenIngestionEvent);\n        this.logger.debug(`Event Reporting - InMemoryJSONEventBuffer - sendBeacon - clearing out current ingestion event ${JSON.stringify(clearCurrenIngestionEvent)}`);\n        this.currentIngestionEvent = this.initializeAndGetCurrentIngestionEvent();\n      } // Any failed ingestion events which were sent before.\n\n\n      if (this.failedIngestionEvents.length > 0) {\n        const failedRecordsCopy = this.failedIngestionEvents.map(record => this.deepCopyCurrentIngestionEvent(record));\n        events.push(...failedRecordsCopy);\n        this.logger.debug(`Event Reporting - InMemoryJSONEventBuffer - sendBeacon - clearing out any failed ingestion event ${JSON.stringify(failedRecordsCopy)}`);\n        this.failedIngestionEvents = [];\n      } // Any cancelled requests due to page-redirects.\n\n\n      if (this.cancellableEvents.size > 0) {\n        this.cancellableEvents.forEach(value => {\n          events.push(...value);\n          this.logger.debug(`Event Reporting - InMemoryJSONEventBuffer - sendBeacon - clearing out each cancellable event ${JSON.stringify(value)}`);\n        });\n        this.cancellableEvents.clear();\n      }\n\n      if (events.length === 0) {\n        return;\n      }\n\n      const beaconData = this.makeBeaconRequestBody(events);\n      this.logger.debug(`Event Reporting - InMemoryJSONEventBuffer - sendBeacon - beacon data to send ${beaconData}`);\n\n      try {\n        /* istanbul ignore else */\n        if (!navigator.sendBeacon(`${this.ingestionURL}?beacon=1`, beaconData)) {\n          this.logger.warn(`Event Reporting - Browser failed to queue beacon data ${beaconData}`);\n        }\n      } catch (error) {\n        this.logger.warn(`Event Reporting - Sending beacon data ${beaconData} failed with error ${error}`);\n      }\n    });\n  }\n\n  reset() {\n    this.maxBufferCapacityBytes = 0;\n    this.totalBufferItems = 0;\n    this.buffer = [];\n    this.bufferSize = 0;\n    this.maxBufferItemCapacityBytes = 0;\n    this.ingestionEventSize = 0;\n    this.flushIntervalMs = 0;\n    this.flushSize = 0;\n    this.failedIngestionEvents = [];\n    this.lock = false;\n    this.beaconEventListener = undefined;\n    this.cancellableEvents.clear();\n  }\n\n  destroy() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.stop();\n      this.reset();\n    });\n  }\n\n}\n\nexports.default = InMemoryJSONEventBuffer;\nInMemoryJSONEventBuffer.SENDING_FAILURE_CODES = new Set([408, 429, 500, 502, 503, 504 // Gateway Timeout.\n]);\nInMemoryJSONEventBuffer.RETRY_FIXED_BACKOFF_WAIT_MS = 0;\nInMemoryJSONEventBuffer.RETRY_SHORT_BACKOFF_MS = 1000;\nInMemoryJSONEventBuffer.RETRY_LONG_BACKOFF_MS = 15000;\nInMemoryJSONEventBuffer.MAX_PAYLOAD_ITEMS = 2;\nInMemoryJSONEventBuffer.MAX_ITEM_SIZE_BYTES_ALLOWED = 3000;","map":{"version":3,"mappings":"cAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;;AAQA;;AACA;;AACA;AAMA;;;;;;;;;AAOA,MAAqBA,uBAArB,CAA4C;EAsC1CC,YACEC,wBADF,EAEEC,yBAFF,EAGEC,YAHF,EAIEC,eAJF,EAKEC,MALF,EAKgB;IA3BR,cAA+B,EAA/B;IACA,kBAAa,CAAb;IACA,kCAA6B,CAA7B;IAEA,0BAAqB,CAArB;IAEA,uBAA0B,CAA1B;IACA,iBAAoB,CAApB;IAEA,6BAA8C,EAA9C;IACA,uBAAkB,EAAlB;IAEA,YAAgB,KAAhB;IAKA,yBAAoB,IAAIC,GAAJ,EAApB;IAGA,0BAAqB,CAAC,gBAAD,EAAmB,mBAAnB,EAAwC,aAAxC,CAArB;;IA2KA,qCAAiCC,KAAD,IAAkD;MACxF,MAAMC,QAAQ,GAAuB;QACnCC,IAAI,EAAEF,KAAK,CAACE,IADuB;QAEnCC,CAAC,EAAEH,KAAK,CAACG,CAF0B;QAGnCC,QAAQ,EAAE,CAAC,GAAGJ,KAAK,CAACI,QAAV;MAHyB,CAArC;MAKA,OAAOH,QAAP;IACD,CAPO;;IA4DA,kBAAa,MAA0BI;MAC7C,IAAI,KAAKC,IAAT,EAAe;QACb;MACD;;MACD,MAAMC,KAAK,GAAyB,KAAKC,QAAL,CAAc,KAAKC,SAAnB,CAApC;;MACA,IAAIF,KAAK,CAACG,MAAN,KAAiB,CAArB,EAAwB;QACtB;MACD;;MACD,KAAKJ,IAAL,GAAY,IAAZ;MACA,MAAMK,IAAI,GAAG,KAAKC,eAAL,CAAqBL,KAArB,CAAb;MACA,IAAIM,MAAM,GAAG,KAAb,CAV6C,CAY7C;MACA;MACA;MACA;;MACA,MAAMC,SAAS,GAAGC,IAAI,CAACC,GAAL,EAAlB;;MACA,IAAI,KAAKC,QAAL,CAAcC,WAAd,CAA0BC,WAA1B,OAA4C,SAAhD,EAA2D;QACzD,KAAKC,iBAAL,CAAuBC,GAAvB,CAA2BP,SAA3B,EAAsCP,KAAtC;MACD;;MAED,IAAI;QACF,KAAKT,MAAL,CAAYwB,KAAZ,CACE,yEAAyEX,IAAI,EAD/E;QAGA,MAAMY,QAAQ,GAAG,MAAM,KAAKC,IAAL,CAAUb,IAAV,CAAvB;QACA,KAAKS,iBAAL,CAAuBK,MAAvB,CAA8BX,SAA9B;;QACA,IAAI,CAACS,QAAQ,CAACG,EAAd,EAAkB;UAChB,KAAK5B,MAAL,CAAY6B,KAAZ,CACE,kFAAkFhB,IAAI,yBAAyBY,QAAQ,CAACK,MAAM,EADhI;UAGAf,MAAM,GAAG,IAAT;QACD,CALD,MAKO;UACL,IAAI;YACF,MAAMgB,IAAI,GAAG,MAAMN,QAAQ,CAACO,IAAT,EAAnB;YACA,KAAKhC,MAAL,CAAYwB,KAAZ,CACE,oFAAoFX,IAAI,aAAaoB,IAAI,CAACC,SAAL,CACnGH,IADmG,CAEpG,EAHH;UAKD,CAPD,CAOE,OAAOI,GAAP,EAAY;YACZ;YACA,KAAKnC,MAAL,CAAYoC,IAAZ,CACE,oFAAoFD,GAAG,eAAetB,IAAI,EAD5G;UAGD;QACF;MACF,CA1BD,CA0BE,OAAOgB,KAAP,EAAc;QACdd,MAAM,GAAG,IAAT;QACA,KAAKf,MAAL,CAAYoC,IAAZ,CACE,oFAAoFvB,IAAI,8BAA8BgB,KAAK,EAD7H;MAGD,CA/BD,SA+BU;QACR,KAAKrB,IAAL,GAAY,KAAZ;MACD;;MAED,IAAIO,MAAJ,EAAY;QACV,KAAKO,iBAAL,CAAuBK,MAAvB,CAA8BX,SAA9B;QACA,KAAKqB,qBAAL,CAA2BC,IAA3B,CAAgC,GAAG7B,KAAnC;MACD;IACF,CA5D8C,CAAvC;;IA9NN,MAAM8B,qBAAqB,GAAG,IAAIC,gCAAJ,CAA2BxC,MAA3B,EAAmCyC,eAAnC,EAA9B;;IACA,MAAM;MAAEC,mBAAmB,EAAEC;IAAvB,IAAmEJ,qBAAzE;IAAA,MAAsDK,cAAc,UAAKL,qBAAL,EAA9D,uBAA8D,CAApE;;IACA,MAAMM,KAAuBhD,yBAAyB,CAACiD,MAA1B,EAA7B;IAAA,MAAM;MAAE1C,IAAF;MAAQC;IAAR,IAASwC,EAAf;IAAA,MAAoBE,IAAI,cAAlB,aAAkB,CAAxB;;IACA,KAAKC,mBAAL,GAA2BnD,yBAAyB,CAACoD,sBAA1B,EAA3B;IACA,KAAK9B,QAAL,GAAa+B,gCAAQN,cAAR,GAA2BG,IAA3B,CAAb;IACAG,MAAM,CAACC,IAAP,CAAY,KAAKhC,QAAjB,EAA2BiC,OAA3B,CAAmCC,GAAG,IAAI,KAAKC,kBAAL,CAAwBhB,IAAxB,CAA6Be,GAA7B,CAA1C;IACA,KAAKjD,IAAL,GAAYA,IAAZ;IACA,KAAKC,CAAL,GAASA,CAAT;IACA,KAAKP,YAAL,GAAoBA,YAApB;IACA,KAAKE,MAAL,GAAcA,MAAd;IACA,KAAKD,eAAL,GAAuB,IAAIwD,GAAJ,CAA6BxD,eAA7B,CAAvB;IACA,MAAM;MACJyD,mBADI;MAEJC,gBAFI;MAGJ9C,SAHI;MAIJ+C,eAJI;MAKJC;IALI,IAMF/D,wBANJ;IAOA,KAAKgE,sBAAL,GAA8BJ,mBAAmB,GAAG,IAApD;IACA,KAAKC,gBAAL,GAAwBA,gBAAxB;IACA,KAAKI,0BAAL,GAAkCC,IAAI,CAACC,KAAL,CAAW,KAAKH,sBAAL,GAA8BH,gBAAzC,CAAlC;IACA,KAAKC,eAAL,GAAuBA,eAAvB;IACA,KAAK/C,SAAL,GAAiBA,SAAjB;IACA,KAAKgD,eAAL,GAAuBA,eAAvB;IACA,KAAKK,qBAAL,GAA6B,KAAKC,qCAAL,EAA7B;;IACA,KAAKC,mBAAL,GAA4BC,CAAD,IAAc,KAAKC,kBAAL,CAAwBD,CAAxB,CAAzC;;IACA,KAAKE,iBAAL;EACD;;EAEOA,iBAAiB;IACvB,IACE,CAAC,KAAKH,mBAAN,IACA,EAAE,YAAYI,MAAd,CADA,IAEA,CAACC,MAAM,CAACC,gBAFR,IAGA,EAAE,cAAcF,MAAhB,CAHA,IAIA,CAACG,QAAQ,CAACD,gBALZ,EAME;MACA;IACD;;IACD,KAAKxE,MAAL,CAAYwB,KAAZ,CACE,uHADF;IAGA+C,MAAM,CAACC,gBAAP,CAAwB,UAAxB,EAAoC,KAAKN,mBAAzC;IACAO,QAAQ,CAACD,gBAAT,CAA0B,kBAA1B,EAA8C,KAAKN,mBAAnD;EACD;;EAEOE,kBAAkB,CAACD,CAAD,EAAS;IACjC;IACA,IACGA,CAAC,CAAC/D,IAAF,KAAW,kBAAX,IAAiCqE,QAAQ,CAACC,eAAT,KAA6B,QAA/D,IACAP,CAAC,CAAC/D,IAAF,KAAW,UAFb,EAGE;MACA,KAAKJ,MAAL,CAAYwB,KAAZ,CACE,gGADF;MAGA,KAAKmD,UAAL;IACD;EACF;;EAEOC,oBAAoB;IAC1B,IACE,CAAC,KAAKV,mBAAN,IACA,EAAE,YAAYI,MAAd,CADA,IAEA,CAACC,MAAM,CAACM,mBAFR,IAGA,EAAE,cAAcP,MAAhB,CAHA,IAIA,CAACG,QAAQ,CAACI,mBALZ,EAME;MACA;IACD;;IACDN,MAAM,CAACM,mBAAP,CAA2B,UAA3B,EAAuC,KAAKX,mBAA5C;IACAO,QAAQ,CAACI,mBAAT,CAA6B,kBAA7B,EAAiD,KAAKX,mBAAtD;IACA,KAAKlE,MAAL,CAAYwB,KAAZ,CACE,4HADF;EAGD;;EAEDsD,KAAK;;;IACH,KAAKF,oBAAL;IACA,KAAKP,iBAAL;IACA,WAAKU,iBAAL,MAAsB,IAAtB,IAAsBlC,aAAtB,GAAsB,MAAtB,GAAsBA,GAAEmC,IAAF,EAAtB;IACA,KAAKD,iBAAL,GAAyB,IAAIE,2BAAJ,CAAsB,KAAKvB,eAA3B,CAAzB;IACA,KAAKqB,iBAAL,CAAuBD,KAAvB,CAA6B,MAAM,KAAKI,UAAL,EAAnC;EACD;;EAEDF,IAAI;;;IACF,WAAKD,iBAAL,MAAsB,IAAtB,IAAsBlC,aAAtB,GAAsB,MAAtB,GAAsBA,GAAEmC,IAAF,EAAtB;IACA,KAAKD,iBAAL,GAAyBI,SAAzB;IACA,KAAKR,UAAL;IACA,KAAKC,oBAAL;EACD;;EAEKQ,OAAO,CAACC,IAAD,EAAgB;;MAC3B,KAAKrF,MAAL,CAAYwB,KAAZ,CACE,wEAAwES,IAAI,CAACC,SAAL,CAAemD,IAAf,CAAoB,EAD9F;MAGA,MAAM;QAAEC,IAAF;QAAQC,EAAR;QAAYC;MAAZ,IAA2BH,IAAjC,EACA;;MACA,MAAMI,kBAAkB,GACtBD,UAAU,IAAI,KAAKE,gBAAL,CAAsBF,UAAtB,EAAkC,KAAKlC,kBAAvC,CADhB;MAGA,MAAMpD,KAAK;QAAKoF,IAAL;QAAWC;MAAX,GAAkBE,kBAAlB,CAAX;MACA,KAAKzF,MAAL,CAAYwB,KAAZ,CACE,0FAA0FS,IAAI,CAACC,SAAL,CACxFhC,KADwF,CAEzF,EAHH;MAKA,MAAMyF,IAAI,GAAG,KAAKC,OAAL,CAAa1F,KAAb,CAAb;;MACA,IAAIyF,IAAI,GAAGjG,uBAAuB,CAACmG,2BAAnC,EAAgE;QAC9D,MAAM,IAAIC,KAAJ,CACJ,+CAA+CH,IAAI,uDAAuDjG,uBAAuB,CAACmG,2BAA2B,SADzJ,CAAN;MAGD;;MACD,IAAI,KAAK9F,eAAL,CAAqBgG,GAArB,CAAyBT,IAAzB,CAAJ,EAAoC;QAClC;QACA,KAAKtF,MAAL,CAAYwB,KAAZ,CACE,iFAAiFS,IAAI,CAACC,SAAL,CAC/EhC,KAD+E,CAEhF,EAHH;QAKA,KAAK8F,oBAAL,CAA0B;UAAEV,IAAF;UAAQC,EAAR;UAAYC,UAAU,EAAEC;QAAxB,CAA1B;QACA;MACD;;MAED,IAAI,KAAKQ,MAAL,EAAJ,EAAmB;QACjB,KAAKjG,MAAL,CAAYoC,IAAZ,CAAiB,wCAAjB;QACA,MAAM,IAAI0D,KAAJ,CAAU,aAAV,CAAN;MACD;;MACD,KAAK9B,qBAAL,CAA2B1D,QAA3B,CAAoCgC,IAApC,CAAyCpC,KAAzC;MACA,KAAKgG,kBAAL,IAA2BP,IAA3B;;MACA,IAAI,KAAKQ,0BAAL,CAAgCR,IAAhC,CAAJ,EAA2C;QACzC,MAAMS,YAAY,GAAG,KAAKC,6BAAL,CAAmC,KAAKrC,qBAAxC,CAArB;QACA,KAAKsC,MAAL,CAAYhE,IAAZ,CAAiB8D,YAAjB;QACA,KAAKG,UAAL,IAAmB,KAAKL,kBAAxB;QACA,KAAKlC,qBAAL,GAA6B,KAAKC,qCAAL,EAA7B;QACA,KAAKjE,MAAL,CAAYwB,KAAZ,CACE,sGAAsGS,IAAI,CAACC,SAAL,CACpG,KAAKoE,MAD+F,CAErG,EAHH;MAKD;IACF;EAAA;;EAEOZ,gBAAgB,CACtBF,UADsB,EAEtBlC,kBAFsB,EAEM;IAE5B,MAAMkD,qBAAqB,GAAG,IAAIjD,GAAJ,CAAgBD,kBAAhB,CAA9B;IACA,MAAMmD,eAAe,GAAGvD,MAAM,CAACC,IAAP,CAAYqC,UAAZ,EAAwBkB,MAAxB,CAA+BrD,GAAG,IAAImD,qBAAqB,CAACT,GAAtB,CAA0B1C,GAA1B,CAAtC,CAAxB;IACAoD,eAAe,CAACrD,OAAhB,CAAwBC,GAAG,IAAI,OAAOmC,UAAU,CAACnC,GAAD,CAAhD;IACA,OAAOmC,UAAP;EACD;;EAEOvB,qCAAqC;IAC3C,MAAM0C,UAAU,GAAG;MACjBvG,IAAI,EAAE,KAAKA,IADM;MAEjBC,CAAC,EAAE,KAAKA,CAFS;MAGjBC,QAAQ,EAAE;IAHO,CAAnB;IAKA,KAAK4F,kBAAL,GAA0B,KAAKN,OAAL,CAAae,UAAb,CAA1B;IACA,OAAOA,UAAP;EACD;;EAWOR,0BAA0B,CAACR,IAAD,EAAa;IAC7C,OACEA,IAAI,GAAG,KAAKO,kBAAZ,IAAkC,KAAKrC,0BAAvC,IACA,KAAKG,qBAAL,CAA2B1D,QAA3B,CAAoCM,MAApC,KAA+ClB,uBAAuB,CAACkH,iBAFzE;EAID;;EAEOhB,OAAO,CAACP,IAAD,EAA+B;IAC5C,IAAIwB,KAAK,GAAG,CAAZ;;IACA,IAAI,OAAOxB,IAAP,KAAgB,QAApB,EAA8B;MAC5B,KAAK,MAAM,CAAChC,GAAD,EAAMyD,KAAN,CAAX,IAA2B5D,MAAM,CAAC6D,OAAP,CAAe1B,IAAf,CAA3B,EAAiD;QAC/CwB,KAAK,IAAI,KAAKG,gBAAL,CAAsB3D,GAAtB,CAAT;QACAwD,KAAK,IAAI,KAAKjB,OAAL,CAAakB,KAAb,CAAT;MACD;IACF,CALD,MAKO;MACLD,KAAK,IAAI,KAAKG,gBAAL,CAAsB3B,IAAtB,CAAT;IACD;;IACD,OAAOwB,KAAP;EACD;;EAEOG,gBAAgB,CAAC3B,IAAD,EAAsB;IAC5C,IAAIwB,KAAK,GAAG,CAAZ;IACA;;IACA,IAAI,OAAOxB,IAAP,KAAgB,QAApB,EAA8B;MAC5BwB,KAAK,IAAIxB,IAAI,CAACzE,MAAL,GAAc,CAAvB;IACD,CAFD,MAEO,IAAI,OAAOyE,IAAP,KAAgB,QAApB,EAA8B;MACnCwB,KAAK,IAAI,CAAT;IACD;;IACD,OAAOA,KAAP;EACD;;EAEOZ,MAAM;IACZ,OACE,KAAKM,UAAL,KAAoB,KAAK3C,sBAAzB,IACA,KAAK0C,MAAL,CAAY1F,MAAZ,KAAuB,KAAK6C,gBAF9B;EAID;;EAEOwD,OAAO;IACb,OAAO,KAAKX,MAAL,CAAY1F,MAAZ,KAAuB,CAAvB,IAA4B,KAAK2F,UAAL,KAAoB,CAAvD;EACD;;EAEO7F,QAAQ,CAACwG,GAAD,EAA+B;IAAA,IAAjBpC,KAAiB,uEAAD,CAAC;;IAC7C,IAAI,KAAKmC,OAAL,EAAJ,EAAoB;MAClB,OAAO,EAAP;IACD;;IACDC,GAAG,GAAGpD,IAAI,CAACqD,GAAL,CAAS,KAAKb,MAAL,CAAY1F,MAArB,EAA6BsG,GAAG,GAAG,CAAnC,CAAN;IACA,MAAME,KAAK,GAAG,KAAKd,MAAL,CAAYe,MAAZ,CAAmBvC,KAAnB,EAA0BoC,GAA1B,CAAd;IACA,OAAOE,KAAP;EACD;;EAgEOE,qBAAqB,CAACC,WAAD,EAAkC;IAC7D,MAAMC,eAAe,GAAwB;MAC3CrG,QAAQ,EAAE,KAAKA,QAD4B;MAE3CsG,MAAM,EAAEF,WAFmC;MAG3CG,aAAa,EAAE,KAAK1E;IAHuB,CAA7C;IAKA,OAAOf,IAAI,CAACC,SAAL,CAAesF,eAAf,CAAP;EACD;;EAEO1G,eAAe,CAACyG,WAAD,EAAkC;IACvD,MAAMC,eAAe,GAAwB;MAC3CrG,QAAQ,EAAE,KAAKA,QAD4B;MAE3CsG,MAAM,EAAEF;IAFmC,CAA7C;IAIA,OAAOtF,IAAI,CAACC,SAAL,CAAesF,eAAf,CAAP;EACD;;EAEaxB,oBAAoB,CAACX,IAAD,EAAgB;;MAChD,KAAKrF,MAAL,CAAYwB,KAAZ,CACE,+FAA+FS,IAAI,CAACC,SAAL,CAC7FmD,IAD6F,CAE9F,EAHH;MAKA,MAAM;QAAEC,IAAF;QAAQC,EAAR;QAAYC;MAAZ,IAA2BH,IAAjC;MACA,MAAMnF,KAAK,GAAuB;QAChCE,IAAI,EAAE,KAAKA,IADqB;QAEhCC,CAAC,EAAE,KAAKA,CAFwB;QAGhCC,QAAQ,EAAE;UAENgF;UACAC;WACGC,WAJG;MAHsB,CAAlC;MAWA,IAAIzE,MAAM,GAAG,KAAb;MACA,IAAIU,QAAQ,GAAa,IAAzB;MACA,MAAMZ,IAAI,GAAG,KAAKC,eAAL,CAAqB,CAACZ,KAAD,CAArB,CAAb;;MACA,IAAI;QACFuB,QAAQ,GAAG,MAAM,KAAKC,IAAL,CAAUb,IAAV,CAAjB;;QACA,IAAIY,QAAQ,CAACG,EAAb,EAAiB;UACf,IAAI;YACF,MAAMG,IAAI,GAAG,MAAMN,QAAQ,CAACO,IAAT,EAAnB;YACA,KAAKhC,MAAL,CAAYwB,KAAZ,CACE,6FAA6FX,IAAI,cAAcoB,IAAI,CAACC,SAAL,CAC7GH,IAD6G,CAE9G,EAHH;UAKD,CAPD,CAOE,OAAOI,GAAP,EAAY;YACZ;YACA,KAAKnC,MAAL,CAAYoC,IAAZ,CACE,gGAAgGD,GAAG,cAActB,IAAI,EADvH;UAGD;;UACD;QACD,CAfD,MAeO;UACL,KAAKb,MAAL,CAAY6B,KAAZ,CACE,wGAAwGhB,IAAI,yBAAyBY,QAAQ,CAACK,MAAM,EADtJ;UAGAf,MAAM,GAAG,IAAT;QACD;MACF,CAvBD,CAuBE,OAAOc,KAAP,EAAc;QACd,KAAK7B,MAAL,CAAYoC,IAAZ,CACE,0EAA0EvB,IAAI,8BAA8BgB,KAAK,GADnH;QAGAd,MAAM,GAAG,IAAT;;QACA,IAAI;UACF;;;;;;;;;;UAUA,IAAI,KAAKI,QAAL,CAAcC,WAAd,CAA0BC,WAA1B,OAA4C,SAAhD,EAA2D;YACzD,MAAMR,IAAI,GAAG,KAAKyG,qBAAL,CAA2B,CAACpH,KAAD,CAA3B,CAAb;YACA,KAAKF,MAAL,CAAYwB,KAAZ,CACE,yFAAyFX,IAAI,EAD/F;;YAGA,IAAI,CAAC8G,SAAS,CAAChD,UAAV,CAAqB,GAAG,KAAK7E,YAAY,WAAzC,EAAsDe,IAAtD,CAAL,EAAkE;cAChEE,MAAM,GAAG,IAAT;YACD,CAFD,MAEO;cACLA,MAAM,GAAG,KAAT;YACD;UACF;QACF,CAtBD,CAsBE,OAAOc,KAAP,EAAc;UACd,KAAK7B,MAAL,CAAYoC,IAAZ,CAAiB,iEAAiEvB,IAAI,EAAtF;UACAE,MAAM,GAAG,IAAT;QACD;MACF;MAED;;;MACA,IAAIA,MAAJ,EAAY;QACV,KAAKf,MAAL,CAAYwB,KAAZ,CACE,+FAA+FX,IAAI,EADrG;QAGA,KAAKwB,qBAAL,CAA2BC,IAA3B,CAAgCpC,KAAhC;MACD;IACF;EAAA;;EAEawB,IAAI,CAACK,IAAD,EAAa;;MAC7B,MAAM6F,OAAO,GAAY,IAAIC,2BAAJ,CACvBnI,uBAAuB,CAACoI,2BADD,EAEvBpI,uBAAuB,CAACqI,sBAFD,EAGvBrI,uBAAuB,CAACsI,qBAHD,CAAzB;;MAKA,IAAI;QACF,IAAIC,UAAU,GAAG,CAAjB;;QACA,OAAOA,UAAU,GAAG,KAAKtE,eAAzB,EAA0C;UACxC,MAAMlC,QAAQ,GAAG,MAAMyG,KAAK,CAAC,KAAKpI,YAAN,EAAoB;YAC9CqI,MAAM,EAAE,MADsC;YAE9CC,OAAO,EAAE;cACPC,aAAa,EAAE,UAAU,KAAKrF,mBAAmB;YAD1C,CAFqC;YAK9CnC,IAAI,EAAEkB;UALwC,CAApB,CAA5B;;UAOA,IAAIN,QAAQ,CAACG,EAAT,IAAe,CAAClC,uBAAuB,CAAC4I,qBAAxB,CAA8CvC,GAA9C,CAAkDtE,QAAQ,CAACK,MAA3D,CAApB,EAAwF;YACtF,OAAOL,QAAP;UACD,CAFD,MAEO;YACL,KAAKzB,MAAL,CAAYoC,IAAZ,CACE,kCAAkCL,IAAI,uBAAuBN,QAAQ,CAACK,MAAM,GAD9E;YAGAmG,UAAU;YACV;;YACA,IAAIA,UAAU,GAAG,KAAKtE,eAAtB,EAAuC;cACrC,MAAM4E,WAAW,GAAGX,OAAO,CAACY,mBAAR,EAApB;cACA,MAAMC,aAAKF,WAAL,CAAN;YACD;UACF;QACF;QACD;;;QACA,IAAIN,UAAU,KAAK,KAAKtE,eAAxB,EAAyC;UACvC,MAAM,IAAImC,KAAJ,CAAU,iCAAiC/D,IAAI,EAA/C,CAAN;QACD;MACF,CA5BD,CA4BE,OAAOF,KAAP,EAAc;QACd,MAAMA,KAAN;MACD;IACF;EAAA;;EAEa8C,UAAU;;MACtB;MACA,MAAM8C,MAAM,GAAG,KAAKnB,MAApB;MACA,KAAKtG,MAAL,CAAYwB,KAAZ,CACE,uFAAuFS,IAAI,CAACC,SAAL,CACrFuF,MADqF,CAEtF,EAHH;MAKA,KAAKnB,MAAL,GAAc,EAAd,EACA;;MACA,IAAI,KAAKtC,qBAAL,CAA2B1D,QAA3B,CAAoCM,MAApC,GAA6C,CAAjD,EAAoD;QAClD,MAAM8H,yBAAyB,GAAG,KAAKrC,6BAAL,CAChC,KAAKrC,qBAD2B,CAAlC;QAGAyD,MAAM,CAACnF,IAAP,CAAYoG,yBAAZ;QACA,KAAK1I,MAAL,CAAYwB,KAAZ,CACE,iGAAiGS,IAAI,CAACC,SAAL,CAC/FwG,yBAD+F,CAEhG,EAHH;QAKA,KAAK1E,qBAAL,GAA6B,KAAKC,qCAAL,EAA7B;MACD,EAED;;;MACA,IAAI,KAAK5B,qBAAL,CAA2BzB,MAA3B,GAAoC,CAAxC,EAA2C;QACzC,MAAM+H,iBAAiB,GAAG,KAAKtG,qBAAL,CAA2BuG,GAA3B,CAA+BC,MAAM,IAC7D,KAAKxC,6BAAL,CAAmCwC,MAAnC,CADwB,CAA1B;QAGApB,MAAM,CAACnF,IAAP,CAAY,GAAGqG,iBAAf;QACA,KAAK3I,MAAL,CAAYwB,KAAZ,CACE,oGAAoGS,IAAI,CAACC,SAAL,CAClGyG,iBADkG,CAEnG,EAHH;QAKA,KAAKtG,qBAAL,GAA6B,EAA7B;MACD,EAED;;;MACA,IAAI,KAAKf,iBAAL,CAAuBqE,IAAvB,GAA8B,CAAlC,EAAqC;QACnC,KAAKrE,iBAAL,CAAuB8B,OAAvB,CAA+B0D,KAAK,IAAG;UACrCW,MAAM,CAACnF,IAAP,CAAY,GAAGwE,KAAf;UACA,KAAK9G,MAAL,CAAYwB,KAAZ,CACE,gGAAgGS,IAAI,CAACC,SAAL,CAC9F4E,KAD8F,CAE/F,EAHH;QAKD,CAPD;QAQA,KAAKxF,iBAAL,CAAuBwH,KAAvB;MACD;;MAED,IAAIrB,MAAM,CAAC7G,MAAP,KAAkB,CAAtB,EAAyB;QACvB;MACD;;MACD,MAAMmI,UAAU,GAAG,KAAKzB,qBAAL,CAA2BG,MAA3B,CAAnB;MACA,KAAKzH,MAAL,CAAYwB,KAAZ,CACE,gFAAgFuH,UAAU,EAD5F;;MAGA,IAAI;QACF;QACA,IAAI,CAACpB,SAAS,CAAChD,UAAV,CAAqB,GAAG,KAAK7E,YAAY,WAAzC,EAAsDiJ,UAAtD,CAAL,EAAwE;UACtE,KAAK/I,MAAL,CAAYoC,IAAZ,CAAiB,yDAAyD2G,UAAU,EAApF;QACD;MACF,CALD,CAKE,OAAOlH,KAAP,EAAc;QACd,KAAK7B,MAAL,CAAYoC,IAAZ,CACE,yCAAyC2G,UAAU,sBAAsBlH,KAAK,EADhF;MAGD;IACF;EAAA;;EAEOmH,KAAK;IACX,KAAKpF,sBAAL,GAA8B,CAA9B;IACA,KAAKH,gBAAL,GAAwB,CAAxB;IACA,KAAK6C,MAAL,GAAc,EAAd;IACA,KAAKC,UAAL,GAAkB,CAAlB;IACA,KAAK1C,0BAAL,GAAkC,CAAlC;IACA,KAAKqC,kBAAL,GAA0B,CAA1B;IACA,KAAKxC,eAAL,GAAuB,CAAvB;IACA,KAAK/C,SAAL,GAAiB,CAAjB;IACA,KAAK0B,qBAAL,GAA6B,EAA7B;IACA,KAAK7B,IAAL,GAAY,KAAZ;IACA,KAAK0D,mBAAL,GAA2BiB,SAA3B;IACA,KAAK7D,iBAAL,CAAuBwH,KAAvB;EACD;;EAEKG,OAAO;;MACX,KAAKjE,IAAL;MACA,KAAKgE,KAAL;IACD;EAAA;;AA9iByC;;AAA5CE;AAC0BxJ,gDAAwB,IAAI6D,GAAJ,CAAQ,CACtD,GADsD,EAEtD,GAFsD,EAGtD,GAHsD,EAItD,GAJsD,EAKtD,GALsD,EAMtD,GANsD,CAMjD;AANiD,CAAR,CAAxB;AAQA7D,sDAA8B,CAA9B;AACAA,iDAAyB,IAAzB;AACAA,gDAAwB,KAAxB;AACAA,4CAAoB,CAApB;AACAA,sDAA8B,IAA9B","names":["InMemoryJSONEventBuffer","constructor","eventBufferConfiguration","eventsClientConfiguration","ingestionURL","importantEvents","logger","Map","event","newEvent","type","v","payloads","__awaiter","lock","batch","getItems","flushSize","length","body","makeRequestBody","failed","timestamp","Date","now","metadata","browserName","toLowerCase","cancellableEvents","set","debug","response","send","delete","ok","error","status","data","json","JSON","stringify","err","warn","failedIngestionEvents","push","userAgentParserResult","DefaultUserAgentParser_1","getParserResult","browserMajorVersion","_browserMajorVersion","clientMetadata","_a","toJSON","rest","authenticationToken","getAuthenticationToken","Object","keys","forEach","key","attributesToFilter","Set","maxBufferCapacityKb","totalBufferItems","flushIntervalMs","retryCountLimit","maxBufferCapacityBytes","maxBufferItemCapacityBytes","Math","round","currentIngestionEvent","initializeAndGetCurrentIngestionEvent","beaconEventListener","e","beaconEventHandler","addEventListeners","global","window","addEventListener","document","visibilityState","sendBeacon","removeEventListeners","removeEventListener","start","intervalScheduler","stop","IntervalScheduler_1","sendEvents","undefined","addItem","item","name","ts","attributes","filteredAttributes","filterAttributes","size","getSize","MAX_ITEM_SIZE_BYTES_ALLOWED","Error","has","sendEventImmediately","isFull","ingestionEventSize","bufferItemThresholdReached","currentEvent","deepCopyCurrentIngestionEvent","buffer","bufferSize","attributesToFilterSet","keysToFilterOut","filter","bufferItem","MAX_PAYLOAD_ITEMS","bytes","value","entries","getPrimitiveSize","isEmpty","end","min","items","splice","makeBeaconRequestBody","batchEvents","ingestionRecord","events","authorization","navigator","backoff","FullJitterBackoff_1","RETRY_FIXED_BACKOFF_WAIT_MS","RETRY_SHORT_BACKOFF_MS","RETRY_LONG_BACKOFF_MS","retryCount","fetch","method","headers","Authorization","SENDING_FAILURE_CODES","backoffTime","nextBackoffAmountMs","Utils_1","clearCurrenIngestionEvent","failedRecordsCopy","map","record","clear","beaconData","reset","destroy","exports"],"sourceRoot":"","sources":["../../src/eventbuffer/InMemoryJSONEventBuffer.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}