{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst BackgroundFilterProcessor_1 = require(\"../backgroundfilter/BackgroundFilterProcessor\");\n\nconst BackgroundBlurStrength_1 = require(\"./BackgroundBlurStrength\");\n\nconst BackgroundBlurVideoFrameProcessorDelegate_1 = require(\"./BackgroundBlurVideoFrameProcessorDelegate\");\n/**\n * [[BackgroundBlurProcessorProvided]] implements [[BackgroundBlurProcessor]].\n * It's a background blur processor and input is passed into a worker that will apply a segmentation\n * to separate the foreground from the background. Then the background will have a blur applied.\n *\n * The [[BackgroundBlurProcessorProvided]] uses WASM and TensorFlow Lite to apply the blurring of the\n * background image as apposed to [[BackgroundBlurProcessorBuiltIn]] that uses the browser's built-in\n * capability to apply the blur.\n */\n\n/** @internal */\n\n\nclass BackgroundBlurProcessorProvided extends BackgroundFilterProcessor_1.default {\n  /**\n   * A constructor that will apply default values if spec and strength are not provided.\n   * If no spec is provided the selfie segmentation model is used with default paths to CDN for the\n   * worker and wasm files used to process each frame.\n   * @param spec The spec defines the assets that will be used for adding background blur to a frame\n   * @param options How much blur to apply to a frame\n   */\n  constructor(spec, options) {\n    super('background blur', spec, options, new BackgroundBlurVideoFrameProcessorDelegate_1.default());\n    this.blurAmount = 0;\n    this.setBlurStrength(options.blurStrength);\n    this.logger.info('BackgroundBlur processor successfully created');\n    this.logger.info(`BackgroundBlur spec: ${this.stringify(this.spec)}`);\n    this.logger.info(`BackgroundBlur options: ${this.stringify(options)}`);\n  }\n\n  validateOptions(options) {\n    super.validateOptions(options);\n\n    if (!options.blurStrength) {\n      throw new Error('processor has null options - blurStrength');\n    }\n  }\n\n  initOnFirstExecution() {\n    this.setBlurPixels();\n  }\n\n  drawImageWithMask(inputCanvas, mask) {\n    // Mask will not be set until the worker has completed handling the predict event. Until the first frame is processed,\n    // the whole frame will be blurred.\n    if (!mask) {\n      mask = new ImageData(this.spec.model.input.width, this.spec.model.input.height);\n    }\n\n    const scaledCtx = this.scaledCanvas.getContext('2d');\n    scaledCtx.putImageData(mask, 0, 0);\n    const {\n      canvasCtx,\n      targetCanvas\n    } = this;\n    const {\n      width,\n      height\n    } = targetCanvas; // draw the mask\n\n    canvasCtx.save();\n    canvasCtx.clearRect(0, 0, width, height);\n    canvasCtx.drawImage(this.scaledCanvas, 0, 0, width, height); // Only overwrite existing pixels.\n\n    canvasCtx.globalCompositeOperation = 'source-in'; // draw image over mask...\n\n    canvasCtx.drawImage(inputCanvas, 0, 0, width, height); // draw under person\n\n    canvasCtx.globalCompositeOperation = 'destination-over';\n    canvasCtx.filter = `blur(${this.blurAmount}px)`;\n    canvasCtx.drawImage(inputCanvas, 0, 0, targetCanvas.width, targetCanvas.height);\n    canvasCtx.restore();\n  }\n\n  setBlurStrength(blurStrength) {\n    this._blurStrength = blurStrength;\n    this.logger.info(`blur strength set to ${this._blurStrength}`);\n    this.setBlurPixels();\n  }\n  /**\n   * Calculate the blur amount based on the blur strength passed in and height of the image being blurred.\n   */\n\n\n  setBlurPixels() {\n    this.blurAmount = BackgroundBlurStrength_1.BlurStrengthMapper.getBlurAmount(this._blurStrength, {\n      height: this.sourceHeight\n    });\n    this.logger.info(`background blur amount set to ${this.blurAmount}`);\n  }\n\n  addObserver(observer) {\n    this.delegate.addObserver(observer);\n  }\n\n  removeObserver(observer) {\n    this.delegate.removeObserver(observer);\n  }\n\n  static isSupported() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const canvas = document.createElement('canvas');\n      const supportsBlurFilter = canvas.getContext('2d').filter !== undefined;\n      canvas.remove();\n      return supportsBlurFilter;\n    });\n  }\n\n}\n\nexports.default = BackgroundBlurProcessorProvided;","map":{"version":3,"mappings":"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","names":["BackgroundBlurProcessorProvided","BackgroundFilterProcessor_1","constructor","spec","options","BackgroundBlurVideoFrameProcessorDelegate_1","setBlurStrength","blurStrength","logger","info","stringify","validateOptions","Error","initOnFirstExecution","setBlurPixels","drawImageWithMask","inputCanvas","mask","ImageData","model","input","width","height","scaledCtx","scaledCanvas","getContext","putImageData","canvasCtx","targetCanvas","save","clearRect","drawImage","globalCompositeOperation","filter","blurAmount","restore","_blurStrength","BackgroundBlurStrength_1","getBlurAmount","sourceHeight","addObserver","observer","delegate","removeObserver","isSupported","canvas","document","createElement","supportsBlurFilter","undefined","remove","exports"],"sourceRoot":"","sources":["../../src/backgroundblurprocessor/BackgroundBlurProcessorProvided.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}