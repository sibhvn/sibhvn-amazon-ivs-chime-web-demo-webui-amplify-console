{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * This class simplifies the process of defining a transform device that\n * does not modify its input device constraints, and provides only a single audio node\n * to apply transforms.\n *\n * Subclass `SingleNodeAudioTransformDevice`, implementing `createSingleAudioNode`.\n */\n\nclass SingleNodeAudioTransformDevice {\n  constructor(inner) {\n    this.inner = inner;\n  }\n\n  mute(_muted) {\n    return __awaiter(this, void 0, void 0, function* () {});\n  }\n  /**\n   * `stop` should be called by the application to free any resources associated\n   * with the device (e.g., workers).\n   *\n   * After this is called, the device should be discarded.\n   */\n\n\n  stop() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      (_a = this.node) === null || _a === void 0 ? void 0 : _a.disconnect();\n    });\n  }\n  /**\n   * Return the inner {@link Device} that the device controller should select as part\n   * of the application of this `AudioTransformDevice`.\n   */\n\n\n  intrinsicDevice() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.inner;\n    });\n  }\n  /**\n   * Optionally return a pair of `AudioNode`s that should be connected to the applied inner\n   * device. The two nodes can be the same, indicating the smallest possible subgraph.\n   *\n   * @param context The `AudioContext` to use when instantiating the nodes.\n   */\n\n\n  createAudioNode(context) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      (_a = this.node) === null || _a === void 0 ? void 0 : _a.disconnect();\n      this.node = yield this.createSingleAudioNode(context);\n      return {\n        start: this.node,\n        end: this.node\n      };\n    });\n  }\n\n}\n\nexports.default = SingleNodeAudioTransformDevice;","map":{"version":3,"mappings":"cAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;;;;;;;;AAOA,MAA8BA,8BAA9B,CAA4D;EAG1DC,YAAsBC,KAAtB,EAAmC;IAAb;EAAiB;;EAEjCC,IAAI,CAACC,MAAD,EAAgB;yDAAmB;EAAA;EAE7C;;;;;;;;EAMMC,IAAI;;;;MACR,WAAKC,IAAL,MAAS,IAAT,IAASC,aAAT,GAAS,MAAT,GAASA,GAAEC,UAAF,EAAT;;EACD;EAED;;;;;;EAIMC,eAAe;;MACnB,OAAO,KAAKP,KAAZ;IACD;EAAA;EAED;;;;;;;;EAMMQ,eAAe,CAACC,OAAD,EAAsB;;;;MACzC,WAAKL,IAAL,MAAS,IAAT,IAASC,aAAT,GAAS,MAAT,GAASA,GAAEC,UAAF,EAAT;MACA,KAAKF,IAAL,GAAY,MAAM,KAAKM,qBAAL,CAA2BD,OAA3B,CAAlB;MACA,OAAO;QACLE,KAAK,EAAE,KAAKP,IADP;QAELQ,GAAG,EAAE,KAAKR;MAFL,CAAP;;EAID;;AAtCyD;;AAA5DS","names":["SingleNodeAudioTransformDevice","constructor","inner","mute","_muted","stop","node","_a","disconnect","intrinsicDevice","createAudioNode","context","createSingleAudioNode","start","end","exports"],"sourceRoot":"","sources":["../../src/devicecontroller/SingleNodeAudioTransformDevice.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}