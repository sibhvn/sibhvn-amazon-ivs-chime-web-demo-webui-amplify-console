{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst CanvasVideoFrameBuffer_1 = require(\"./CanvasVideoFrameBuffer\");\n\nconst DEFAULT_FRAMERATE = 15;\n/**\n * [[DefaultVideoFrameProcessorPipeline]] implements {@link VideoFrameProcessorPipeline}.\n * It constructs a buffer {@link CanvasVideoFrameBuffer} as source by default and invokes processor based on `framerate`.\n * The default output type is `MediaStream`.\n */\n\nclass DefaultVideoFrameProcessorPipeline {\n  constructor(logger, stages) {\n    this.logger = logger;\n    this.stages = stages;\n    this.fr = DEFAULT_FRAMERATE; // initialize with dummy inactive MediaStream to keep strict type\n\n    this.outputMediaStream = new MediaStream();\n    this.videoInput = document.createElement('video');\n    this.canvasOutput = document.createElement('canvas');\n    this.outputCtx = this.canvasOutput.getContext('2d');\n    this.canvasInput = document.createElement('canvas');\n    this.inputCtx = this.canvasInput.getContext('2d');\n    this.inputVideoStream = null;\n    this.sourceBuffers = [];\n    this.destBuffers = [];\n    this.observers = new Set();\n    this.hasStarted = false;\n\n    this.process = _event => __awaiter(this, void 0, void 0, function* () {\n      if (!this.inputVideoStream) {\n        return;\n      }\n\n      const processVideoStart = performance.now(); // videoWidth is intrinsic video width\n\n      if (this.videoInput.videoWidth) {\n        if (this.canvasInput.width !== this.videoInput.videoWidth) {\n          this.canvasInput.width = this.videoInput.videoWidth;\n          this.canvasInput.height = this.videoInput.videoHeight;\n          this.sourceBuffers[0].height = this.canvasInput.height;\n          this.sourceBuffers[0].width = this.canvasInput.width;\n          this.sourceBuffers[0].framerate = this.framerate;\n        }\n\n        this.inputCtx.drawImage(this.videoInput, 0, 0);\n      } // processes input buffers\n\n\n      let buffers = [];\n      buffers.push(this.sourceBuffers[0]);\n\n      try {\n        for (const proc of this.processors) {\n          buffers = yield proc.process(buffers);\n        }\n      } catch (_error) {\n        this.forEachObserver(obs => {\n          if (obs.processingDidFailToStart) {\n            obs.processingDidFailToStart();\n          }\n        });\n        return;\n      }\n\n      this.destBuffers = buffers;\n      let imageSource;\n\n      try {\n        imageSource = yield this.destBuffers[0].asCanvasImageSource();\n      } catch (error) {\n        if (this.inputVideoStream) {\n          this.logger.info('buffers are destroyed and pipeline could not start');\n          this.forEachObserver(obs => {\n            if (obs.processingDidFailToStart) {\n              obs.processingDidFailToStart();\n            }\n          });\n        }\n\n        return;\n      } // finally draws the image\n\n\n      const frameWidth = imageSource.width;\n      const frameHeight = imageSource.height;\n\n      if (frameWidth !== 0 && frameHeight !== 0) {\n        if (this.canvasOutput.width !== frameWidth && this.canvasOutput.height !== frameHeight) {\n          this.canvasOutput.width = frameWidth;\n          this.canvasOutput.height = frameHeight;\n        }\n\n        this.outputCtx.drawImage(imageSource, 0, 0, frameWidth, frameHeight, 0, 0, frameWidth, frameHeight);\n\n        if (!this.hasStarted) {\n          this.hasStarted = true;\n          this.forEachObserver(observer => {\n            if (observer.processingDidStart) {\n              observer.processingDidStart();\n            }\n          });\n        }\n      } // measures time\n\n\n      const processVideoLatency = performance.now() - processVideoStart;\n      const leave = 1000 * 2 / this.framerate - processVideoLatency; // half fps\n\n      const nextFrameDelay = Math.max(0, 1000 / this.framerate - processVideoLatency);\n\n      if (leave <= 0) {\n        this.forEachObserver(obs => {\n          if (obs.processingLatencyTooHigh) {\n            obs.processingLatencyTooHigh(processVideoLatency);\n          }\n        });\n      } // TODO: use requestAnimationFrame which is more organic and allows browser to conserve resources by its choices.\n\n      /* @ts-ignore */\n\n\n      this.lastTimeOut = setTimeout(this.process, nextFrameDelay);\n    });\n  }\n\n  destroy() {\n    this.stop();\n\n    if (this.stages) {\n      for (const stage of this.stages) {\n        stage.destroy();\n      }\n    }\n  }\n\n  get framerate() {\n    return this.fr;\n  } // A negative framerate will cause `captureStream` to throw `NotSupportedError`.\n  // The setter prevents this by switching to the default framerate if less than 0.\n\n\n  set framerate(value) {\n    this.fr = value < 0 ? DEFAULT_FRAMERATE : value;\n  }\n\n  stop() {\n    // empty stream, stop pipeline\n    // null input media stream stops the pipeline.\n    this.videoInput.removeEventListener('loadedmetadata', this.process);\n    this.videoInput.srcObject = null; // Clean the input stream and buffers.\n\n    this.destroyInputMediaStreamAndBuffers(); // Stop all the output tracks, but don't discard the media stream,\n    // because it's how other parts of the codebase recognize when\n    // a selected stream is part of this transform device.\n\n    if (this.outputMediaStream) {\n      for (const track of this.outputMediaStream.getVideoTracks()) {\n        track.stop();\n      }\n    }\n\n    if (this.lastTimeOut) {\n      clearTimeout(this.lastTimeOut);\n      this.lastTimeOut = undefined;\n    }\n\n    if (this.hasStarted) {\n      this.hasStarted = false;\n      this.forEachObserver(observer => {\n        if (observer.processingDidStop) {\n          observer.processingDidStop();\n        }\n      });\n    }\n  }\n\n  addObserver(observer) {\n    this.observers.add(observer);\n  }\n\n  removeObserver(observer) {\n    this.observers.delete(observer);\n  }\n\n  getInputMediaStream() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.inputVideoStream;\n    });\n  }\n\n  getActiveOutputMediaStream() {\n    if (this.outputMediaStream && this.outputMediaStream.active) {\n      return this.outputMediaStream;\n    }\n\n    return this.outputMediaStream = this.canvasOutput.captureStream(this.framerate);\n  }\n  /**\n   * `inputMediaStream` is by default used to construct one {@link CanvasVideoFrameBuffer}\n   * The buffer will be fed into the first {@link VideoFrameProcessor}.\n   */\n\n\n  setInputMediaStream(inputMediaStream) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!inputMediaStream) {\n        this.stop();\n        return;\n      }\n\n      if (inputMediaStream.getVideoTracks().length === 0) {\n        this.logger.error('No video tracks in input media stream, ignoring');\n        return;\n      }\n\n      this.inputVideoStream = inputMediaStream;\n      const settings = this.inputVideoStream.getVideoTracks()[0].getSettings();\n      this.logger.info(`processing pipeline input stream settings ${JSON.stringify(settings)}`);\n      this.canvasOutput.width = settings.width;\n      this.canvasOutput.height = settings.height;\n      this.videoInput.addEventListener('loadedmetadata', this.process);\n      this.videoInput.srcObject = this.inputVideoStream; // avoid iOS safari full screen video\n\n      this.videoInput.setAttribute('playsinline', 'true'); // create sources\n\n      const canvasBuffer = new CanvasVideoFrameBuffer_1.default(this.canvasInput);\n      this.sourceBuffers.push(canvasBuffer);\n      this.videoInput.load();\n\n      try {\n        yield this.videoInput.play();\n      } catch (_a) {\n        this.logger.warn('Video element play() overrided by another load().');\n      }\n    });\n  }\n\n  set processors(stages) {\n    this.stages = stages;\n  }\n\n  get processors() {\n    return this.stages;\n  }\n\n  forEachObserver(observerFunc) {\n    for (const observer of this.observers) {\n      setTimeout(() => {\n        observerFunc(observer);\n      }, 0);\n    }\n  }\n\n  destroyInputMediaStreamAndBuffers() {\n    if (this.inputVideoStream) {\n      for (const track of this.inputVideoStream.getTracks()) {\n        track.stop();\n      }\n    }\n\n    this.inputVideoStream = null;\n\n    for (const buffer of this.sourceBuffers) {\n      buffer.destroy();\n    }\n\n    this.sourceBuffers = [];\n  }\n\n}\n\nexports.default = DefaultVideoFrameProcessorPipeline;","map":{"version":3,"mappings":"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","names":["DEFAULT_FRAMERATE","DefaultVideoFrameProcessorPipeline","constructor","logger","stages","MediaStream","document","createElement","canvasOutput","getContext","canvasInput","Set","_event","__awaiter","inputVideoStream","processVideoStart","performance","now","videoInput","videoWidth","width","height","videoHeight","sourceBuffers","framerate","inputCtx","drawImage","buffers","push","proc","processors","process","_error","forEachObserver","obs","processingDidFailToStart","destBuffers","imageSource","asCanvasImageSource","error","info","frameWidth","frameHeight","outputCtx","hasStarted","observer","processingDidStart","processVideoLatency","leave","nextFrameDelay","Math","max","processingLatencyTooHigh","lastTimeOut","setTimeout","destroy","stop","stage","fr","value","removeEventListener","srcObject","destroyInputMediaStreamAndBuffers","outputMediaStream","track","getVideoTracks","clearTimeout","undefined","processingDidStop","addObserver","observers","add","removeObserver","delete","getInputMediaStream","getActiveOutputMediaStream","active","captureStream","setInputMediaStream","inputMediaStream","length","settings","getSettings","JSON","stringify","addEventListener","setAttribute","canvasBuffer","CanvasVideoFrameBuffer_1","load","play","warn","observerFunc","getTracks","buffer","exports"],"sourceRoot":"","sources":["../../src/videoframeprocessor/DefaultVideoFrameProcessorPipeline.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}