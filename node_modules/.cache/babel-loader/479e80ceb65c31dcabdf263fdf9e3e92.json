{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst MeetingSessionStatusCode_1 = require(\"../meetingsession/MeetingSessionStatusCode\");\n\nconst DefaultSDP_1 = require(\"../sdp/DefaultSDP\");\n\nconst BaseTask_1 = require(\"./BaseTask\");\n/*\n * [[FinishGatheringICECandidatesTask]] add ice-candidate event handler on peer connection to\n * collect ice candidates and wait for peer connection ice gathering state to complete\n */\n\n\nclass FinishGatheringICECandidatesTask extends BaseTask_1.default {\n  constructor(context) {\n    let chromeVpnTimeoutMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FinishGatheringICECandidatesTask.CHROME_VPN_TIMEOUT_MS;\n    super(context.logger);\n    this.context = context;\n    this.chromeVpnTimeoutMs = chromeVpnTimeoutMs;\n    this.taskName = 'FinishGatheringICECandidatesTask';\n  }\n\n  removeEventListener() {\n    if (this.context.peer) {\n      this.context.peer.removeEventListener('icecandidate', this.context.iceCandidateHandler);\n\n      if (!this.context.turnCredentials) {\n        this.context.peer.removeEventListener('icegatheringstatechange', this.context.iceGatheringStateEventHandler);\n      }\n    }\n  }\n\n  cancel() {\n    let error; // TODO: Remove when the Chrome VPN reconnect bug is fixed.\n    // In Chrome, SDK may fail to establish TURN session after VPN reconnect.\n    // https://bugs.chromium.org/p/webrtc/issues/detail?id=9097\n\n    if (this.context.browserBehavior.requiresIceCandidateGatheringTimeoutWorkaround()) {\n      if (this.chromeVpnTimeoutMs < this.context.meetingSessionConfiguration.connectionTimeoutMs) {\n        const duration = Date.now() - this.startTimestampMs;\n\n        if (duration > this.chromeVpnTimeoutMs) {\n          error = new Error(`canceling ${this.name()} due to the meeting status code: ${MeetingSessionStatusCode_1.default.ICEGatheringTimeoutWorkaround}`);\n        }\n      }\n    } // Just in case. The baseCancel behavior should prevent this.\n\n    /* istanbul ignore else */\n\n\n    if (this.cancelPromise) {\n      error = error || new Error(`canceling ${this.name()}`);\n      this.cancelPromise(error);\n      delete this.cancelPromise;\n    }\n  }\n\n  run() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.context.peer) {\n        this.logAndThrow(`session does not have peer connection; bypass ice gathering`);\n      }\n\n      if (this.context.browserBehavior.requiresCheckForSdpConnectionAttributes()) {\n        if (new DefaultSDP_1.default(this.context.peer.localDescription.sdp).hasCandidatesForAllMLines()) {\n          this.context.logger.info(`ice gathering already complete; bypass gathering, current local description ${this.context.peer.localDescription.sdp}`);\n          return;\n        }\n      } else {\n        this.context.logger.info(`iOS device does not require checking for connection attributes in SDP, current local description ${this.context.peer.localDescription.sdp}`);\n      }\n      /*\n       * To bypass waiting for events, it is required that \"icegatheringstate\" to be complete and sdp to have candidate\n       * For Firefox, it takes long for iceGatheringState === 'complete'\n       * Ref: https://github.com/aws/amazon-chime-sdk-js/issues/609\n       */\n\n\n      if ((this.context.browserBehavior.hasFirefoxWebRTC() || this.context.peer.iceGatheringState === 'complete') && new DefaultSDP_1.default(this.context.peer.localDescription.sdp).hasCandidates()) {\n        this.context.logger.info('ice gathering state is complete and candidates are in SDP; bypass gathering');\n        return;\n      }\n\n      try {\n        yield new Promise((resolve, reject) => {\n          this.cancelPromise = error => {\n            this.removeEventListener();\n            reject(error);\n          };\n\n          if (!this.context.turnCredentials) {\n            // if one day, we found a case where a FinishGatheringICECandidate did not resolve but ice gathering state is complete and SDP answer has ice candidates\n            // we may need to enable this\n            this.context.iceGatheringStateEventHandler = () => {\n              if (this.context.peer.iceGatheringState === 'complete') {\n                this.removeEventListener();\n                resolve();\n                delete this.cancelPromise;\n                return;\n              }\n            };\n\n            this.context.peer.addEventListener('icegatheringstatechange', this.context.iceGatheringStateEventHandler);\n          }\n\n          this.context.iceCandidateHandler = event => {\n            this.context.logger.info(`ice candidate: ${event.candidate ? event.candidate.candidate : '(null)'} state: ${this.context.peer.iceGatheringState}`); // Ice candidate arrives, do not need to wait anymore.\n            // https://webrtcglossary.com/trickle-ice/\n\n            if (event.candidate) {\n              if (DefaultSDP_1.default.isRTPCandidate(event.candidate.candidate)) {\n                this.context.iceCandidates.push(event.candidate);\n              } // Could there be a case the candidate is not written to SDP ?\n\n\n              if (this.context.turnCredentials && this.context.iceCandidates.length >= 1) {\n                this.context.logger.info('gathered at least one relay candidate');\n                this.removeEventListener();\n                resolve();\n                delete this.cancelPromise;\n                return;\n              }\n            } // Ice candidate gathering is complete, additional barrier to make sure sdp contain an ice candidate.\n            // TODO: Could there be a race where iceGatheringState is flipped after this task is run ? This could only be handled if ice state is monitored persistently.\n\n\n            if (this.context.peer.iceGatheringState === 'complete') {\n              this.context.logger.info('done gathering ice candidates');\n              this.removeEventListener();\n\n              if (!new DefaultSDP_1.default(this.context.peer.localDescription.sdp).hasCandidates() || this.context.iceCandidates.length === 0) {\n                reject(new Error('no ice candidates were gathered'));\n                delete this.cancelPromise;\n              } else {\n                resolve();\n                delete this.cancelPromise;\n              }\n            }\n          }; // SDK does not catch candidate itself and send to sever. Rather, WebRTC handles candidate events and writes candidate to SDP.\n\n\n          this.context.peer.addEventListener('icecandidate', this.context.iceCandidateHandler);\n          this.startTimestampMs = Date.now();\n        });\n      } catch (error) {\n        throw error;\n      } finally {\n        /* istanbul ignore else */\n        if (this.startTimestampMs) {\n          this.context.iceGatheringDurationMs = Math.round(Date.now() - this.startTimestampMs);\n        }\n      }\n    });\n  }\n\n}\n\nexports.default = FinishGatheringICECandidatesTask;\nFinishGatheringICECandidatesTask.CHROME_VPN_TIMEOUT_MS = 5000;","map":{"version":3,"mappings":"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","names":["FinishGatheringICECandidatesTask","BaseTask_1","constructor","context","chromeVpnTimeoutMs","CHROME_VPN_TIMEOUT_MS","logger","removeEventListener","peer","iceCandidateHandler","turnCredentials","iceGatheringStateEventHandler","cancel","error","browserBehavior","requiresIceCandidateGatheringTimeoutWorkaround","meetingSessionConfiguration","connectionTimeoutMs","duration","Date","now","startTimestampMs","Error","name","MeetingSessionStatusCode_1","ICEGatheringTimeoutWorkaround","cancelPromise","run","logAndThrow","requiresCheckForSdpConnectionAttributes","DefaultSDP_1","localDescription","sdp","hasCandidatesForAllMLines","info","hasFirefoxWebRTC","iceGatheringState","hasCandidates","Promise","resolve","reject","addEventListener","event","candidate","isRTPCandidate","iceCandidates","push","length","iceGatheringDurationMs","Math","round","exports"],"sourceRoot":"","sources":["../../src/task/FinishGatheringICECandidatesTask.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}