{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst IntervalScheduler_1 = require(\"../scheduler/IntervalScheduler\");\n\nclass DefaultActiveSpeakerDetector {\n  constructor(realtimeController, selfAttendeeId, hasBandwidthPriorityCallback) {\n    let waitIntervalMs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1000;\n    let updateIntervalMs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 200;\n    this.realtimeController = realtimeController;\n    this.selfAttendeeId = selfAttendeeId;\n    this.hasBandwidthPriorityCallback = hasBandwidthPriorityCallback;\n    this.waitIntervalMs = waitIntervalMs;\n    this.updateIntervalMs = updateIntervalMs;\n    this.speakerScores = {};\n    this.speakerMuteState = {};\n    this.detectorCallbackToHandler = new Map();\n    this.detectorCallbackToScoresTimer = new Map();\n    this.detectorCallbackToActivityTimer = new Map();\n    this.hasBandwidthPriority = false;\n    this.mostRecentUpdateTimestamp = {};\n  }\n\n  needUpdate(attendeeId) {\n    if (!this.activeSpeakers) {\n      return true;\n    }\n\n    return this.speakerScores[attendeeId] === 0 && this.activeSpeakers.includes(attendeeId) || this.speakerScores[attendeeId] > 0 && !this.activeSpeakers.includes(attendeeId);\n  }\n\n  updateActiveSpeakers(policy, callback, attendeeId) {\n    if (!this.needUpdate(attendeeId)) {\n      return;\n    }\n\n    const sortedSpeakers = [];\n    const attendeeIds = Object.keys(this.speakerScores);\n\n    for (let i = 0; i < attendeeIds.length; i++) {\n      const attendeeId = attendeeIds[i];\n      sortedSpeakers.push({\n        attendeeId: attendeeId,\n        activeScore: this.speakerScores[attendeeId]\n      });\n    }\n\n    const sortedAttendeeIds = sortedSpeakers.sort((s1, s2) => s2.activeScore - s1.activeScore).filter(function (s) {\n      return s.activeScore > 0;\n    }).map(function (s) {\n      return s.attendeeId;\n    });\n    this.activeSpeakers = sortedAttendeeIds;\n    callback(sortedAttendeeIds);\n    const selfIsActive = sortedAttendeeIds.length > 0 && sortedAttendeeIds[0] === this.selfAttendeeId;\n    const hasBandwidthPriority = selfIsActive && policy.prioritizeVideoSendBandwidthForActiveSpeaker();\n    const hasBandwidthPriorityDidChange = this.hasBandwidthPriority !== hasBandwidthPriority;\n\n    if (hasBandwidthPriorityDidChange) {\n      this.hasBandwidthPriority = hasBandwidthPriority;\n      this.hasBandwidthPriorityCallback(hasBandwidthPriority);\n    }\n  }\n\n  updateScore(policy, callback, attendeeId, volume, muted) {\n    const activeScore = policy.calculateScore(attendeeId, volume, muted);\n\n    if (this.speakerScores[attendeeId] !== activeScore) {\n      this.speakerScores[attendeeId] = activeScore;\n      this.mostRecentUpdateTimestamp[attendeeId] = Date.now();\n      this.updateActiveSpeakers(policy, callback, attendeeId);\n    }\n  }\n\n  subscribe(policy, callback, scoresCallback, scoresCallbackIntervalMs) {\n    const handler = (attendeeId, present) => {\n      if (!present) {\n        this.speakerScores[attendeeId] = 0;\n        this.mostRecentUpdateTimestamp[attendeeId] = Date.now();\n        this.updateActiveSpeakers(policy, callback, attendeeId);\n        return;\n      }\n\n      this.realtimeController.realtimeSubscribeToVolumeIndicator(attendeeId, (attendeeId, volume, muted, _signalStrength) => {\n        this.mostRecentUpdateTimestamp[attendeeId] = Date.now();\n\n        if (muted !== null) {\n          this.speakerMuteState[attendeeId] = muted;\n        }\n\n        this.updateScore(policy, callback, attendeeId, volume, muted);\n      });\n    };\n\n    this.detectorCallbackToHandler.set(callback, handler);\n    const activityTimer = new IntervalScheduler_1.default(this.updateIntervalMs);\n    activityTimer.start(() => {\n      for (const attendeeId in this.speakerScores) {\n        if (Date.now() - this.mostRecentUpdateTimestamp[attendeeId] > this.waitIntervalMs) {\n          this.updateScore(policy, callback, attendeeId, 0, this.speakerMuteState[attendeeId]);\n        }\n      }\n    });\n    this.detectorCallbackToActivityTimer.set(callback, activityTimer);\n\n    if (scoresCallback && scoresCallbackIntervalMs) {\n      const scoresTimer = new IntervalScheduler_1.default(scoresCallbackIntervalMs);\n      scoresTimer.start(() => {\n        scoresCallback(this.speakerScores);\n      });\n      this.detectorCallbackToScoresTimer.set(callback, scoresTimer);\n    }\n\n    this.realtimeController.realtimeSubscribeToAttendeeIdPresence(handler);\n  }\n\n  unsubscribe(callback) {\n    const handler = this.detectorCallbackToHandler.get(callback);\n    this.detectorCallbackToHandler.delete(callback);\n\n    if (handler) {\n      this.realtimeController.realtimeUnsubscribeToAttendeeIdPresence(handler);\n    }\n\n    const activityTimer = this.detectorCallbackToActivityTimer.get(callback);\n\n    if (activityTimer) {\n      activityTimer.stop();\n      this.detectorCallbackToActivityTimer.delete(callback);\n    }\n\n    const scoresTimer = this.detectorCallbackToScoresTimer.get(callback);\n\n    if (scoresTimer) {\n      scoresTimer.stop();\n      this.detectorCallbackToHandler.delete(callback);\n    }\n  }\n\n  destroy() {\n    return __awaiter(this, void 0, void 0, function* () {\n      for (const handler of this.detectorCallbackToHandler.values()) {\n        this.realtimeController.realtimeUnsubscribeToAttendeeIdPresence(handler);\n      }\n\n      for (const activityTimer of this.detectorCallbackToActivityTimer.values()) {\n        activityTimer.stop();\n      }\n\n      for (const scoresTimer of this.detectorCallbackToScoresTimer.values()) {\n        scoresTimer.stop();\n      }\n\n      this.detectorCallbackToHandler.clear();\n      this.detectorCallbackToActivityTimer.clear();\n      this.detectorCallbackToScoresTimer.clear();\n    });\n  }\n\n}\n\nexports.default = DefaultActiveSpeakerDetector;","map":{"version":3,"mappings":"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","names":["DefaultActiveSpeakerDetector","constructor","realtimeController","selfAttendeeId","hasBandwidthPriorityCallback","waitIntervalMs","updateIntervalMs","Map","needUpdate","attendeeId","activeSpeakers","speakerScores","includes","updateActiveSpeakers","policy","callback","sortedSpeakers","attendeeIds","Object","keys","i","length","push","activeScore","sortedAttendeeIds","sort","s1","s2","filter","s","map","selfIsActive","hasBandwidthPriority","prioritizeVideoSendBandwidthForActiveSpeaker","hasBandwidthPriorityDidChange","updateScore","volume","muted","calculateScore","mostRecentUpdateTimestamp","Date","now","subscribe","scoresCallback","scoresCallbackIntervalMs","handler","present","realtimeSubscribeToVolumeIndicator","_signalStrength","speakerMuteState","detectorCallbackToHandler","set","activityTimer","IntervalScheduler_1","start","detectorCallbackToActivityTimer","scoresTimer","detectorCallbackToScoresTimer","realtimeSubscribeToAttendeeIdPresence","unsubscribe","get","delete","realtimeUnsubscribeToAttendeeIdPresence","stop","destroy","values","clear","exports"],"sourceRoot":"","sources":["../../src/activespeakerdetector/DefaultActiveSpeakerDetector.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}