{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst LogLevel_1 = require(\"../logger/LogLevel\");\n\nconst AsyncScheduler_1 = require(\"../scheduler/AsyncScheduler\");\n/**\n * A task that wraps another task and ensures it is run only once,\n * regardless of how many times `run` is called.\n *\n * This allows you to implement a kind of barrier synchronization.\n */\n\n\nclass OnceTask {\n  constructor(logger, task, dependencies) {\n    this.logger = logger;\n    this.task = task;\n    this.dependencies = dependencies; // Whether we have canceled.\n\n    this.canceled = false;\n  }\n\n  name() {\n    return `${this.task.name()} (once)`;\n  }\n\n  cancel() {\n    // We want to preserve one interesting property: the deepest dependency that hasn't\n    // already finished or been canceled is the first to be canceled, and its failure\n    // will propagate back up the promise chain.\n    //\n    // We can't just cancel ourselves with cancelPromise -- we will cut off the rest of\n    // the tree. Nor can we necessarily do it on the same event loop tick, because the\n    // cancelation might be subtly async.\n    //\n    // Instead, we immediately cancel each dependency, and then we cancel the current\n    // task (if it's running), and then we cancel via our promise escape hatch if needed.\n\n    /* istanbul ignore if */\n    if (this.canceled) {\n      return;\n    }\n\n    if (this.dependencies) {\n      for (const dep of this.dependencies) {\n        dep.cancel();\n      }\n    } // Do this on the next tick so that our canceled dependencies cascade.\n\n\n    this.logger.info(`Canceling ${this.name()}`);\n    AsyncScheduler_1.default.nextTick(() => this.task.cancel());\n    this.canceled = true;\n\n    if (this.cancelPromise) {\n      AsyncScheduler_1.default.nextTick(() => this.cancelPromise(new Error(`canceling ${this.name()}`)));\n    }\n  }\n\n  logDependencies() {\n    if (this.logger.getLogLevel() > LogLevel_1.default.INFO) {\n      return;\n    }\n\n    if (!this.dependencies) {\n      return;\n    }\n\n    const names = this.dependencies.filter(d => d).map(d => d.name()).join(', ');\n    this.logger.info(`${this.task.name()} waiting for dependencies: ${names}`);\n  }\n\n  run() {\n    if (this.promise) {\n      return this.promise;\n    }\n\n    const dependencies = this.dependencies ? Promise.all(this.dependencies.map(d => d === null || d === void 0 ? void 0 : d.run())) : Promise.resolve();\n    this.logDependencies();\n    this.ongoing = dependencies.then(() => this.task.run());\n    return this.promise = new Promise((resolve, reject) => {\n      this.cancelPromise = reject;\n      this.ongoing.then(resolve).catch(reject);\n    });\n  }\n\n  setParent(parentTask) {\n    this.task.setParent(parentTask);\n  }\n\n}\n\nexports.default = OnceTask;","map":{"version":3,"mappings":"cAAA;AACA;;;;;;AAGA;;AACA;AAGA;;;;;;;;AAMA,MAAqBA,QAArB,CAA6B;EAY3BC,YACUC,MADV,EAEUC,IAFV,EAGUC,YAHV,EAG6C;IAFnC;IACA;IACA,iCAAmC,CAN7C;;IACQ,gBAAW,KAAX;EAMJ;;EAEJC,IAAI;IACF,OAAO,GAAG,KAAKF,IAAL,CAAUE,IAAV,EAAgB,SAA1B;EACD;;EAEDC,MAAM;IACJ;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA,IAAI,KAAKC,QAAT,EAAmB;MACjB;IACD;;IAED,IAAI,KAAKH,YAAT,EAAuB;MACrB,KAAK,MAAMI,GAAX,IAAkB,KAAKJ,YAAvB,EAAqC;QACnCI,GAAG,CAACF,MAAJ;MACD;IACF,CArBG,CAuBJ;;;IACA,KAAKJ,MAAL,CAAYO,IAAZ,CAAiB,aAAa,KAAKJ,IAAL,EAAW,EAAzC;IACAK,yBAAeC,QAAf,CAAwB,MAAM,KAAKR,IAAL,CAAUG,MAAV,EAA9B;IACA,KAAKC,QAAL,GAAgB,IAAhB;;IAEA,IAAI,KAAKK,aAAT,EAAwB;MACtBF,yBAAeC,QAAf,CAAwB,MAAM,KAAKC,aAAL,CAAmB,IAAIC,KAAJ,CAAU,aAAa,KAAKR,IAAL,EAAW,EAAlC,CAAnB,CAA9B;IACD;EACF;;EAEDS,eAAe;IACb,IAAI,KAAKZ,MAAL,CAAYa,WAAZ,KAA4BC,mBAASC,IAAzC,EAA+C;MAC7C;IACD;;IACD,IAAI,CAAC,KAAKb,YAAV,EAAwB;MACtB;IACD;;IACD,MAAMc,KAAK,GAAG,KAAKd,YAAL,CACXe,MADW,CACJC,CAAC,IAAIA,CADD,EAEXC,GAFW,CAEPD,CAAC,IAAIA,CAAC,CAACf,IAAF,EAFE,EAGXiB,IAHW,CAGN,IAHM,CAAd;IAIA,KAAKpB,MAAL,CAAYO,IAAZ,CAAiB,GAAG,KAAKN,IAAL,CAAUE,IAAV,EAAgB,8BAA8Ba,KAAK,EAAvE;EACD;;EAEDK,GAAG;IACD,IAAI,KAAKC,OAAT,EAAkB;MAChB,OAAO,KAAKA,OAAZ;IACD;;IAED,MAAMpB,YAAY,GAAG,KAAKA,YAAL,GACjBqB,OAAO,CAACC,GAAR,CAAY,KAAKtB,YAAL,CAAkBiB,GAAlB,CAAsBD,CAAC,IAAIA,CAAC,SAAD,KAAC,WAAD,GAAC,MAAD,IAAC,CAAEG,GAAH,EAA3B,CAAZ,CADiB,GAEjBE,OAAO,CAACE,OAAR,EAFJ;IAIA,KAAKb,eAAL;IAEA,KAAKc,OAAL,GAAexB,YAAY,CAACyB,IAAb,CAAkB,MAAM,KAAK1B,IAAL,CAAUoB,GAAV,EAAxB,CAAf;IAEA,OAAQ,KAAKC,OAAL,GAAe,IAAIC,OAAJ,CAAY,CAACE,OAAD,EAAUG,MAAV,KAAoB;MACrD,KAAKlB,aAAL,GAAqBkB,MAArB;MACA,KAAKF,OAAL,CAAaC,IAAb,CAAkBF,OAAlB,EAA2BI,KAA3B,CAAiCD,MAAjC;IACD,CAHsB,CAAvB;EAID;;EAEDE,SAAS,CAACC,UAAD,EAAiB;IACxB,KAAK9B,IAAL,CAAU6B,SAAV,CAAoBC,UAApB;EACD;;AA1F0B;;AAA7BC","names":["OnceTask","constructor","logger","task","dependencies","name","cancel","canceled","dep","info","AsyncScheduler_1","nextTick","cancelPromise","Error","logDependencies","getLogLevel","LogLevel_1","INFO","names","filter","d","map","join","run","promise","Promise","all","resolve","ongoing","then","reject","catch","setParent","parentTask","exports"],"sourceRoot":"","sources":["../../src/task/OnceTask.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}